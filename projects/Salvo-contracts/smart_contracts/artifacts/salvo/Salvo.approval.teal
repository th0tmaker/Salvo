#pragma version 11
#pragma typetrack false

// smart_contracts.salvo.contract.Salvo.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 8 1000000 TMPL_GEN_UNIX TMPL_UPDATABLE
    bytecblock 0x00 0x151f7c75 "g_" "c_" 0x01 "r_" "game_id" 0x0000000000000000 "s_" "l_" 0x0000 0x068101
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0x6333cd9d 0xb66d2f56 0x8996bb37 0x5381d6a8 0x7815fe41 0x0b42d12a 0xbbfa8e01 0xf85053ad 0x06f0d132 0x5be219f0 0x3ffbca24 0x81e90542 0xdada0c68 0xa0e81872 // method "calc_single_box_cost(uint8,uint16)uint64", method "read_gen_unix()uint64", method "read_grid_cell_value_by_index(uint64,uint8)uint8", method "read_grid_cell_value_at_coords(uint64,uint8,uint8)uint8", method "does_box_user_registry_exist(account)bool", method "does_box_game_grid_exist(uint64)bool", method "does_box_game_state_exist(uint64)bool", method "does_box_game_character_exist(account)bool", method "read_box_game_lobby(uint64)address[]", method "generate()void", method "get_box_user_registry(pay)void", method "new_game(pay,pay,pay,pay,pay,uint8)void", method "mimc_tester((uint8,uint8),(uint8,uint8)[],uint8,uint8,uint64)(uint8,uint8)[]", method "update()void"
    txna ApplicationArgs 0
    match main_calc_single_box_cost_route@5 main_read_gen_unix_route@6 main_read_grid_cell_value_by_index_route@7 main_read_grid_cell_value_at_coords_route@8 main_does_box_user_registry_exist_route@9 main_does_box_game_grid_exist_route@10 main_does_box_game_state_exist_route@11 main_does_box_game_character_exist_route@12 main_read_box_game_lobby_route@13 main_generate_route@14 main_get_box_user_registry_route@15 main_new_game_route@16 main_mimc_tester_route@17 main_update_route@18

main_after_if_else@19:
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    intc_1 // 0
    return

main_update_route@18:
    // smart_contracts/salvo/contract.py:363
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main_mimc_tester_route@17:
    // smart_contracts/salvo/contract.py:259
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    // smart_contracts/salvo/contract.py:259
    // @arc4.abimethod
    callsub mimc_tester
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_new_game_route@16:
    // smart_contracts/salvo/contract.py:157
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    pushint 5 // 5
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 4 // 4
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/salvo/contract.py:157
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_get_box_user_registry_route@15:
    // smart_contracts/salvo/contract.py:136
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/salvo/contract.py:136
    // @arc4.abimethod
    callsub get_box_user_registry
    intc_0 // 1
    return

main_generate_route@14:
    // smart_contracts/salvo/contract.py:124-125
    // # Generate the smart contract application client
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_read_box_game_lobby_route@13:
    // smart_contracts/salvo/contract.py:100-101
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:100-101
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    callsub read_box_game_lobby
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_character_exist_route@12:
    // smart_contracts/salvo/contract.py:95-96
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:95-96
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_character_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_state_exist_route@11:
    // smart_contracts/salvo/contract.py:90-91
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:90-91
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_state_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_grid_exist_route@10:
    // smart_contracts/salvo/contract.py:85-86
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:85-86
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_grid_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_user_registry_exist_route@9:
    // smart_contracts/salvo/contract.py:80-81
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:80-81
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_user_registry_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_at_coords_route@8:
    // smart_contracts/salvo/contract.py:70-71
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/salvo/contract.py:70-71
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_at_coords
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_by_index_route@7:
    // smart_contracts/salvo/contract.py:62-63
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:62-63
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_by_index
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_gen_unix_route@6:
    // smart_contracts/salvo/contract.py:57-58
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:60
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 5 // TMPL_GEN_UNIX
    // smart_contracts/salvo/contract.py:57-58
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calc_single_box_cost_route@5:
    // smart_contracts/salvo/contract.py:43-44
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:29-30
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:43-44
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_cost
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.salvo.subroutines.assert_coords_in_range(row: bytes, col: bytes) -> void:
assert_coords_in_range:
    // smart_contracts/salvo/subroutines.py:9-10
    // @subroutine
    // def assert_coords_in_range(row: arc4.UInt8, col: arc4.UInt8) -> None:
    proto 2 0
    // smart_contracts/salvo/subroutines.py:11
    // assert row < cst.GRID_SIZE and col < cst.GRID_SIZE, err.INVALID_POS_COORDS
    frame_dig -2
    pushbytes 0x0b
    b<
    bz assert_coords_in_range_bool_false@3
    frame_dig -1
    pushbytes 0x0b
    b<
    bz assert_coords_in_range_bool_false@3
    intc_0 // 1

assert_coords_in_range_bool_merge@4:
    // smart_contracts/salvo/subroutines.py:11
    // assert row < cst.GRID_SIZE and col < cst.GRID_SIZE, err.INVALID_POS_COORDS
    assert // Invalid position coordinates. Ensure boh row and column indices are within valid range.
    retsub

assert_coords_in_range_bool_false@3:
    intc_1 // 0
    b assert_coords_in_range_bool_merge@4


// smart_contracts.salvo.subroutines.find_valid_path_neighbors(game_id: uint64, box_game_grid: bytes, coords: bytes) -> bytes, bytes:
find_valid_path_neighbors:
    // smart_contracts/salvo/subroutines.py:28-34
    // # Find every valid path cell that neighbors given coords
    // @subroutine
    // def find_valid_path_neighbors(
    //     game_id: UInt64,
    //     box_game_grid: BoxMap[UInt64, ta.GameGrid],
    //     coords: ta.GridCoords,
    // ) -> ta.ValidPathNeighbors:
    proto 3 2
    intc_1 // 0
    pushbytes ""
    dup
    // smart_contracts/salvo/subroutines.py:37-39
    // neighbors = ta.Neighbors(
    //     placeholder_coords, placeholder_coords, placeholder_coords, placeholder_coords
    // )
    bytec 7 // 0x0000000000000000
    dup
    // smart_contracts/salvo/subroutines.py:41-42
    // # Extract current position coordinates (row, col) and initialize valid neighbor counter
    // row, col = coords.native
    frame_dig -1
    extract 0 1 // on error: Index access is out of bounds
    dup
    cover 2
    frame_dig -1
    extract 1 1 // on error: Index access is out of bounds
    cover 2
    // smart_contracts/salvo/subroutines.py:43
    // count = arc4.UInt8(0)
    bytec_0 // 0x00
    dup
    cover 3
    // smart_contracts/salvo/subroutines.py:47
    // row > 0
    swap
    bytec_0 // 0x00
    b>
    swap
    cover 2
    // smart_contracts/salvo/subroutines.py:47-50
    // row > 0
    // and is_path_cell(  # 'is_path_cell' checks if North neighbor is a valid path cell
    //     game_id, box_game_grid, arc4.UInt8(row.native - 1), col
    // )
    bz find_valid_path_neighbors_after_if_else@3
    // smart_contracts/salvo/subroutines.py:49
    // game_id, box_game_grid, arc4.UInt8(row.native - 1), col
    frame_dig -1
    // smart_contracts/salvo/subroutines.py:41-42
    // # Extract current position coordinates (row, col) and initialize valid neighbor counter
    // row, col = coords.native
    intc_1 // 0
    // smart_contracts/salvo/subroutines.py:49
    // game_id, box_game_grid, arc4.UInt8(row.native - 1), col
    getbyte
    intc_0 // 1
    -
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 0
    // smart_contracts/salvo/subroutines.py:24
    // convert_grid_coords_to_index(row, col),
    frame_dig 5
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    frame_dig -3
    frame_dig -2
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:25
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    b==
    frame_dig 6
    frame_bury 7
    frame_dig 3
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:47-50
    // row > 0
    // and is_path_cell(  # 'is_path_cell' checks if North neighbor is a valid path cell
    //     game_id, box_game_grid, arc4.UInt8(row.native - 1), col
    // )
    bz find_valid_path_neighbors_after_if_else@3
    // smart_contracts/salvo/subroutines.py:52-53
    // # Overwrite placeholder coords w/ valid North neighbor coords (row-1, col) at current count index
    // neighbors[count.native] = ta.GridCoords((arc4.UInt8(row.native - 1), col))
    frame_dig 0
    frame_dig 5
    concat
    // smart_contracts/salvo/subroutines.py:37-39
    // neighbors = ta.Neighbors(
    //     placeholder_coords, placeholder_coords, placeholder_coords, placeholder_coords
    // )
    bytec 7 // 0x0000000000000000
    // smart_contracts/salvo/subroutines.py:52-53
    // # Overwrite placeholder coords w/ valid North neighbor coords (row-1, col) at current count index
    // neighbors[count.native] = ta.GridCoords((arc4.UInt8(row.native - 1), col))
    swap
    replace2 0
    // smart_contracts/salvo/subroutines.py:54
    // count = arc4.UInt8(count.native + 1)  # Increment count by 1
    bytec 4 // 0x01
    frame_bury 7
    frame_bury 8

find_valid_path_neighbors_after_if_else@3:
    frame_dig 7
    dup
    frame_bury 6
    frame_dig 8
    dup
    cover 2
    frame_bury 3
    // smart_contracts/salvo/subroutines.py:58
    // row.native + 1 < cst.GRID_SIZE
    frame_dig -1
    // smart_contracts/salvo/subroutines.py:41-42
    // # Extract current position coordinates (row, col) and initialize valid neighbor counter
    // row, col = coords.native
    intc_1 // 0
    // smart_contracts/salvo/subroutines.py:58
    // row.native + 1 < cst.GRID_SIZE
    getbyte
    intc_0 // 1
    +
    dup
    frame_bury 2
    pushint 11 // 11
    <
    swap
    frame_bury 7
    swap
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:58-61
    // row.native + 1 < cst.GRID_SIZE
    // and is_path_cell(  # 'is_path_cell' checks if South neighbor is a valid path cell
    //     game_id, box_game_grid, arc4.UInt8(row.native + 1), col
    // )
    bz find_valid_path_neighbors_after_if_else@6
    // smart_contracts/salvo/subroutines.py:60
    // game_id, box_game_grid, arc4.UInt8(row.native + 1), col
    frame_dig 2
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 0
    // smart_contracts/salvo/subroutines.py:24
    // convert_grid_coords_to_index(row, col),
    frame_dig 5
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    frame_dig -3
    frame_dig -2
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:25
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    b==
    frame_dig 6
    frame_bury 7
    frame_dig 3
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:58-61
    // row.native + 1 < cst.GRID_SIZE
    // and is_path_cell(  # 'is_path_cell' checks if South neighbor is a valid path cell
    //     game_id, box_game_grid, arc4.UInt8(row.native + 1), col
    // )
    bz find_valid_path_neighbors_after_if_else@6
    // smart_contracts/salvo/subroutines.py:63-64
    // # Overwrite placeholder coords w/ valid South neighbor coords (row+1, col) at current count index
    // neighbors[count.native] = ta.GridCoords((arc4.UInt8(row.native + 1), col))
    frame_dig 0
    frame_dig 5
    concat
    frame_dig 6
    btoi
    dup
    pushint 4 // 4
    <
    assert // Index access is out of bounds
    dup
    intc_2 // 2
    *
    frame_dig 3
    swap
    uncover 3
    replace3
    // smart_contracts/salvo/subroutines.py:65
    // count = arc4.UInt8(count.native + 1)  # Increment count by 1
    swap
    intc_0 // 1
    +
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    frame_bury 7
    frame_bury 8

find_valid_path_neighbors_after_if_else@6:
    frame_dig 7
    dup
    frame_bury 6
    frame_dig 8
    dup
    cover 2
    frame_bury 3
    // smart_contracts/salvo/subroutines.py:69
    // col > 0
    frame_dig 5
    bytec_0 // 0x00
    b>
    swap
    frame_bury 7
    swap
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:69-72
    // col > 0
    // and is_path_cell(  # 'is_path_cell' checks if West neighbor is a valid path cell
    //     game_id, box_game_grid, row, arc4.UInt8(col.native - 1)
    // )
    bz find_valid_path_neighbors_after_if_else@9
    // smart_contracts/salvo/subroutines.py:71
    // game_id, box_game_grid, row, arc4.UInt8(col.native - 1)
    frame_dig -1
    // smart_contracts/salvo/subroutines.py:41-42
    // # Extract current position coordinates (row, col) and initialize valid neighbor counter
    // row, col = coords.native
    intc_0 // 1
    // smart_contracts/salvo/subroutines.py:71
    // game_id, box_game_grid, row, arc4.UInt8(col.native - 1)
    getbyte
    intc_0 // 1
    -
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 5
    // smart_contracts/salvo/subroutines.py:24
    // convert_grid_coords_to_index(row, col),
    frame_dig 4
    swap
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    frame_dig -3
    frame_dig -2
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:25
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    b==
    frame_dig 6
    frame_bury 7
    frame_dig 3
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:69-72
    // col > 0
    // and is_path_cell(  # 'is_path_cell' checks if West neighbor is a valid path cell
    //     game_id, box_game_grid, row, arc4.UInt8(col.native - 1)
    // )
    bz find_valid_path_neighbors_after_if_else@9
    // smart_contracts/salvo/subroutines.py:74-75
    // # Overwrite placeholder coords w/ valid West neighbor coords (row, col-1) at current count index
    // neighbors[count.native] = ta.GridCoords((row, arc4.UInt8(col.native - 1)))
    frame_dig 4
    frame_dig 5
    concat
    frame_dig 6
    btoi
    dup
    pushint 4 // 4
    <
    assert // Index access is out of bounds
    dup
    intc_2 // 2
    *
    frame_dig 3
    swap
    uncover 3
    replace3
    // smart_contracts/salvo/subroutines.py:76
    // count = arc4.UInt8(count.native + 1)  # Increment count by 1
    swap
    intc_0 // 1
    +
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    frame_bury 7
    frame_bury 8

find_valid_path_neighbors_after_if_else@9:
    frame_dig 7
    dup
    frame_bury 6
    frame_dig 8
    dup
    cover 2
    frame_bury 3
    // smart_contracts/salvo/subroutines.py:80
    // col.native + 1 < cst.GRID_SIZE
    frame_dig -1
    // smart_contracts/salvo/subroutines.py:41-42
    // # Extract current position coordinates (row, col) and initialize valid neighbor counter
    // row, col = coords.native
    intc_0 // 1
    // smart_contracts/salvo/subroutines.py:80
    // col.native + 1 < cst.GRID_SIZE
    getbyte
    intc_0 // 1
    +
    dup
    frame_bury 1
    pushint 11 // 11
    <
    swap
    frame_bury 7
    swap
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:80-83
    // col.native + 1 < cst.GRID_SIZE
    // and is_path_cell(  # 'is_path_cell' checks if East neighbor is a valid path cell
    //     game_id, box_game_grid, row, arc4.UInt8(col.native + 1)
    // )
    bz find_valid_path_neighbors_after_if_else@12
    // smart_contracts/salvo/subroutines.py:82
    // game_id, box_game_grid, row, arc4.UInt8(col.native + 1)
    frame_dig 1
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    dup
    frame_bury 5
    // smart_contracts/salvo/subroutines.py:24
    // convert_grid_coords_to_index(row, col),
    frame_dig 4
    swap
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    frame_dig -3
    frame_dig -2
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:25
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:21-25
    // return get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(row, col),
    // ) == arc4.UInt8(0)
    b==
    frame_dig 6
    frame_bury 7
    frame_dig 3
    frame_bury 8
    // smart_contracts/salvo/subroutines.py:80-83
    // col.native + 1 < cst.GRID_SIZE
    // and is_path_cell(  # 'is_path_cell' checks if East neighbor is a valid path cell
    //     game_id, box_game_grid, row, arc4.UInt8(col.native + 1)
    // )
    bz find_valid_path_neighbors_after_if_else@12
    // smart_contracts/salvo/subroutines.py:85-86
    // # Overwrite placeholder coords w/ valid East neighbor coords (row, col+1) at current count index
    // neighbors[count.native] = ta.GridCoords((row, arc4.UInt8(col.native + 1)))
    frame_dig 4
    frame_dig 5
    concat
    frame_dig 6
    btoi
    dup
    pushint 4 // 4
    <
    assert // Index access is out of bounds
    dup
    intc_2 // 2
    *
    frame_dig 3
    swap
    uncover 3
    replace3
    // smart_contracts/salvo/subroutines.py:87
    // count = arc4.UInt8(count.native + 1)
    swap
    intc_0 // 1
    +
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    frame_bury 7
    frame_bury 8

find_valid_path_neighbors_after_if_else@12:
    frame_dig 8
    frame_dig 7
    // smart_contracts/salvo/subroutines.py:89-90
    // # Return tuple implicitly w/ a copy of neighbors array and the count variable
    // return neighbors.copy(), count
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts.salvo.subroutines.convert_grid_coords_to_index(row: bytes, col: bytes) -> bytes:
convert_grid_coords_to_index:
    // smart_contracts/salvo/subroutines.py:121-123
    // # Convert game grid row and col coords to their equivalent array index
    // @subroutine
    // def convert_grid_coords_to_index(row: arc4.UInt8, col: arc4.UInt8) -> arc4.UInt8:
    proto 2 1
    // smart_contracts/salvo/subroutines.py:126
    // row.native * cst.GRID_SIZE + col.native
    frame_dig -2
    btoi
    pushint 11 // 11
    *
    frame_dig -1
    btoi
    +
    // smart_contracts/salvo/subroutines.py:129-130
    // # Return index value wrapped in an UInt8 data type
    // return arc4.UInt8(i)
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// smart_contracts.salvo.subroutines.get_grid_cell_value(game_id: uint64, box_game_grid: bytes, i: bytes) -> bytes:
get_grid_cell_value:
    // smart_contracts/salvo/subroutines.py:133-137
    // # Get the value of a grid cell at the equivalent flattened 1D array index
    // @subroutine
    // def get_grid_cell_value(
    //     game_id: UInt64, box_game_grid: BoxMap[UInt64, ta.GameGrid], i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/subroutines.py:138-139
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in box_game_grid, err.GAME_ID_NOT_FOUND
    frame_dig -3
    itob
    frame_dig -2
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/subroutines.py:140
    // assert i.native < cst.TOTAL_GRID_CELLS, err.INVALID_POS_INDEX
    frame_dig -1
    btoi
    dup
    pushint 121 // 121
    <
    assert // Invalid position index. Ensure index value is within valid range.
    // smart_contracts/salvo/subroutines.py:142-143
    // # Access the game grid box contents, at the given index, and return the byte value
    // return box_game_grid[game_id][i.native]
    swap
    box_get
    assert // check BoxMap entry exists
    swap
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    retsub


// smart_contracts.salvo.contract.Salvo.calc_single_box_cost(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_cost:
    // smart_contracts/salvo/contract.py:43-47
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_cost(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/salvo/contract.py:51
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/salvo/contract.py:50
    // size_cost = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/salvo/contract.py:50-52
    // size_cost = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/salvo/contract.py:54-55
    // # Return single box total cost amount
    // return base_cost.native + size_cost
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_by_index(game_id: uint64, i: bytes) -> bytes:
read_grid_cell_value_by_index:
    // smart_contracts/salvo/contract.py:62-66
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_by_index(
    //     self, game_id: UInt64, i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 2 1
    // smart_contracts/salvo/contract.py:67-68
    // # Return byte value at grid cell index
    // return srt.get_grid_cell_value(game_id, self.box_game_grid, i)
    frame_dig -2
    bytec_2 // "g_"
    frame_dig -1
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_at_coords(game_id: uint64, x: bytes, y: bytes) -> bytes:
read_grid_cell_value_at_coords:
    // smart_contracts/salvo/contract.py:70-74
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_at_coords(
    //     self, game_id: UInt64, x: arc4.UInt8, y: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/contract.py:77
    // game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    frame_dig -2
    frame_dig -1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:75-78
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    frame_dig -3
    // smart_contracts/salvo/contract.py:77
    // game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    bytec_2 // "g_"
    // smart_contracts/salvo/contract.py:75-78
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    uncover 2
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_user_registry_exist(account: bytes) -> uint64:
does_box_user_registry_exist:
    // smart_contracts/salvo/contract.py:80-82
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_user_registry_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:83
    // return self.box_user_registry.maybe(account)[1]
    bytec 5 // "r_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_grid_exist(game_id: uint64) -> uint64:
does_box_game_grid_exist:
    // smart_contracts/salvo/contract.py:85-87
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_grid_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:88
    // return self.box_game_grid.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec_2 // "g_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_state_exist(game_id: uint64) -> uint64:
does_box_game_state_exist:
    // smart_contracts/salvo/contract.py:90-92
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_state_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:93
    // return self.box_game_state.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec 8 // "s_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_character_exist(account: bytes) -> uint64:
does_box_game_character_exist:
    // smart_contracts/salvo/contract.py:95-97
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_character_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:98
    // return self.box_game_character.maybe(account)[1]
    bytec_3 // "c_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.read_box_game_lobby(game_id: uint64) -> bytes:
read_box_game_lobby:
    // smart_contracts/salvo/contract.py:100-102
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    // def read_box_game_lobby(self, game_id: UInt64) -> ta.GameLobby:
    proto 1 1
    intc_1 // 0
    dup
    // smart_contracts/salvo/contract.py:103-104
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in self.box_game_lobby, err.GAME_ID_NOT_FOUND
    frame_dig -1
    itob
    bytec 9 // "l_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/contract.py:106-107
    // # Retrieve byte array of current user addresses from the box using the game id parameter
    // game_lobby_b_arr = self.box_game_lobby[game_id]
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_lobby entry exists
    // smart_contracts/salvo/contract.py:109-110
    // # Define a dynamic array to append all remaining active users
    // users_in_lobby = ta.GameLobby()
    bytec 10 // 0x0000
    swap
    // smart_contracts/salvo/contract.py:112-113
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    len
    intc_1 // 0

read_box_game_lobby_for_header@1:
    // smart_contracts/salvo/contract.py:112-113
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 4
    <
    bz read_box_game_lobby_after_for@6
    // smart_contracts/salvo/contract.py:114-115
    // # Extract the bytes representing the user address
    // user_addr_bytes = op.extract(game_lobby_b_arr, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    pushint 32 // 32
    extract3
    dup
    frame_bury 0
    // smart_contracts/salvo/contract.py:116-117
    // # Only append address if its bytes do NOT equal to a zeroed byte array of size 32
    // if user_addr_bytes != Bytes(cst.ZEROED_ADDR_BYTES):
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    frame_dig 3
    frame_bury 1
    bz read_box_game_lobby_after_if_else@4
    // smart_contracts/salvo/contract.py:119
    // users_in_lobby.append(arc4.Address(user_account))
    frame_dig 3
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    pushint 32 // 32
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

read_box_game_lobby_after_if_else@4:
    frame_dig 1
    frame_bury 3
    // smart_contracts/salvo/contract.py:112-113
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    pushint 32 // 32
    +
    frame_bury 5
    b read_box_game_lobby_for_header@1

read_box_game_lobby_after_for@6:
    // smart_contracts/salvo/contract.py:121-122
    // # Return the array containing the remaining active users in the game lobby
    // return users_in_lobby
    frame_dig 3
    frame_bury 0
    retsub


// smart_contracts.salvo.contract.Salvo.generate() -> void:
generate:
    // smart_contracts/salvo/contract.py:133-134
    // # Set Global State variables to their default starting values
    // self.game_id = UInt64(1)
    bytec 6 // "game_id"
    intc_0 // 1
    app_global_put
    retsub


// smart_contracts.salvo.contract.Salvo.get_box_user_registry(box_r_pay: uint64) -> void:
get_box_user_registry:
    // smart_contracts/salvo/contract.py:136-137
    // @arc4.abimethod
    // def get_box_user_registry(self, box_r_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/salvo/contract.py:138-139
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    global GroupSize
    intc_2 // 2
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:140
    // assert Txn.sender not in self.box_user_registry, err.BOX_FOUND
    bytec 5 // "r_"
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Box found. Ensure the does not exist already.
    // smart_contracts/salvo/contract.py:143-144
    // # assert box_r_pay.amount == cst.BOX_R_COST, err.INSUFFICIENT_PAY_AMOUNT
    // assert box_r_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:146
    // box_r_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:145-147
    // assert (
    //     box_r_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:154
    // expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    global Round
    pushint 30 // 30
    +
    itob
    // smart_contracts/salvo/contract.py:149-155
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    pushbytes 0x0000000000000000000000000000000000
    swap
    concat
    // smart_contracts/salvo/contract.py:149-150
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    bytec 5 // "r_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:149-155
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    swap
    box_put
    retsub


// smart_contracts.salvo.contract.Salvo.new_game(box_g_pay: uint64, box_s_pay: uint64, box_c_pay: uint64, box_l_pay: uint64, stake_pay: uint64, lobby_size: bytes) -> void:
new_game:
    // smart_contracts/salvo/contract.py:157-166
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     box_g_pay: gtxn.PaymentTransaction,
    //     box_s_pay: gtxn.PaymentTransaction,
    //     box_c_pay: gtxn.PaymentTransaction,
    //     box_l_pay: gtxn.PaymentTransaction,
    //     stake_pay: gtxn.PaymentTransaction,
    //     lobby_size: arc4.UInt8,
    // ) -> None:
    proto 6 0
    // smart_contracts/salvo/contract.py:167-168
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 6, err.INVALID_GROUP_SIZE
    global GroupSize
    pushint 6 // 6
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:170
    // assert box_g_pay.amount >= cst.BOX_G_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -6
    gtxns Amount
    pushint 54900 // 54900
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:171
    // assert box_s_pay.amount >= cst.BOX_S_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -5
    gtxns Amount
    pushint 27700 // 27700
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:172
    // assert box_c_pay.amount >= cst.BOX_C_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -4
    gtxns Amount
    pushint 18100 // 18100
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:173
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    frame_dig -3
    gtxns Amount
    // smart_contracts/salvo/contract.py:175
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    frame_dig -1
    btoi
    dup
    cover 2
    pushint 32 // 32
    *
    dup
    cover 2
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/salvo/contract.py:174
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/salvo/contract.py:173-176
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    // ), err.INSUFFICIENT_PAY_AMOUNT
    swap
    callsub calc_single_box_cost
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:178
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    frame_dig -2
    gtxns Amount
    dup
    intc 4 // 1000000
    >=
    // smart_contracts/salvo/contract.py:178-180
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:179
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    frame_dig 2
    pushint 500000000 // 500000000
    <=
    // smart_contracts/salvo/contract.py:178-180
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:180
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    frame_dig 2
    intc 4 // 1000000
    %
    // smart_contracts/salvo/contract.py:178-180
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bnz new_game_bool_false@4
    intc_0 // 1

new_game_bool_merge@5:
    // smart_contracts/salvo/contract.py:177-181
    // assert (
    //     stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    //     and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    //     and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    // ), err.INVALID_STAKE_AMOUNT
    assert // Invalid stake amount. Value must be a multiple of 1 and within permitted bounds.
    // smart_contracts/salvo/contract.py:183
    // assert box_g_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -6
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:184
    // assert box_s_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -5
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:185
    // assert box_c_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:186
    // assert box_l_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:187
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match sender address.
    // smart_contracts/salvo/contract.py:190
    // box_g_pay.receiver == Global.current_application_address
    frame_dig -6
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:189-191
    // assert (
    //     box_g_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:193
    // box_s_pay.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:192-194
    // assert (
    //     box_s_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:196
    // box_c_pay.receiver == Global.current_application_address
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:195-197
    // assert (
    //     box_c_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:199
    // box_l_pay.receiver == Global.current_application_address
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:198-200
    // assert (
    //     box_l_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:202
    // stake_pay.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:201-203
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:206
    // lobby_size >= cst.MIN_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x02
    b>=
    // smart_contracts/salvo/contract.py:206-208
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@9
    // smart_contracts/salvo/contract.py:207
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x04
    b<=
    // smart_contracts/salvo/contract.py:206-208
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@9
    // smart_contracts/salvo/contract.py:208
    // and lobby_size.native % 2 == 0
    frame_dig 0
    intc_2 // 2
    %
    // smart_contracts/salvo/contract.py:206-208
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bnz new_game_bool_false@9
    intc_0 // 1

new_game_bool_merge@10:
    // smart_contracts/salvo/contract.py:205-209
    // assert (
    //     lobby_size >= cst.MIN_LOBBY_SIZE
    //     and lobby_size <= cst.MAX_LOBBY_SIZE
    //     and lobby_size.native % 2 == 0
    // ), err.INVALID_LOBBY_SIZE
    assert // Invalid Lobby size. Value must be an even number and within permitted bounds.
    // smart_contracts/salvo/contract.py:211-212
    // # Create a new box storage unit for the game grid w/ the current global game_id value as key
    // self.box_game_grid[self.game_id] = ta.GameGrid.from_bytes(cst.ZEROED_GRID_BYTES)
    intc_1 // 0
    bytec 6 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    dup
    itob
    bytec_2 // "g_"
    dig 1
    concat
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    box_put
    // smart_contracts/salvo/contract.py:221
    // expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    global LatestTimestamp
    pushint 1200 // 1200
    +
    itob
    // smart_contracts/salvo/contract.py:222
    // prize_pot=arc4.UInt64(stake_pay.amount),
    frame_dig 2
    itob
    // smart_contracts/salvo/contract.py:223
    // admin_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/salvo/contract.py:216
    // staking_closed=arc4.Bool(False),  # noqa: FBT003
    bytec_0 // 0x00
    // smart_contracts/salvo/contract.py:214-224
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    frame_dig -1
    concat
    // smart_contracts/salvo/contract.py:219
    // active_players=arc4.UInt8(1),
    bytec 4 // 0x01
    // smart_contracts/salvo/contract.py:214-224
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    // smart_contracts/salvo/contract.py:220
    // box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    pushbytes 0x0020
    // smart_contracts/salvo/contract.py:214-224
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/salvo/contract.py:214-215
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    bytec 8 // "s_"
    dig 2
    concat
    // smart_contracts/salvo/contract.py:214-224
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    swap
    box_put
    // smart_contracts/salvo/contract.py:228-231
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    frame_dig 1
    bzero
    // smart_contracts/salvo/contract.py:228-229
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    bytec 9 // "l_"
    uncover 2
    concat
    // smart_contracts/salvo/contract.py:228-231
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    dup
    box_del
    pop
    dup
    uncover 2
    box_put
    // smart_contracts/salvo/contract.py:233-234
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    bytec_3 // "c_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:233-240
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    //     arc4.UInt8(1),
    //     arc4.UInt8(6),
    //     arc4.UInt8(5),
    //     arc4.UInt8(0),
    //     arc4.UInt8(1),
    // )
    pushbytes 0x0106050001
    box_put
    // smart_contracts/salvo/contract.py:246
    // game_lobby_bref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/salvo/contract.py:248-249
    // # Increment game id by 1 for next new game instance
    // self.game_id += 1
    intc_0 // 1
    +
    bytec 6 // "game_id"
    swap
    app_global_put
    retsub

new_game_bool_false@9:
    intc_1 // 0
    b new_game_bool_merge@10

new_game_bool_false@4:
    intc_1 // 0
    b new_game_bool_merge@5


// smart_contracts.salvo.contract.Salvo.mimc_tester(position: bytes, movement: bytes, action: bytes, direction: bytes, salt: uint64) -> bytes:
mimc_tester:
    // smart_contracts/salvo/contract.py:259-267
    // @arc4.abimethod
    // def mimc_tester(
    //     self,
    //     position: ta.GridCoords,
    //     movement: ta.CharMovement,
    //     action: arc4.UInt8,
    //     direction: arc4.UInt8,
    //     salt: UInt64,
    // ) -> arc4.DynamicArray[ta.GridCoords]:
    proto 5 1
    intc_1 // 0
    dupn 5
    pushbytes ""
    dupn 6

mimc_tester_while_top@18:
    pushint 5610 // 5610
    global OpcodeBudget
    >
    bz mimc_tester_after_while@23
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 11 // 0x068101
    itxn_field ApprovalProgram
    bytec 11 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b mimc_tester_while_top@18

mimc_tester_after_while@23:
    // smart_contracts/salvo/contract.py:272-273
    // # Extract row and column values from the given position argument
    // row, col = position.native
    frame_dig -5
    extract 0 1 // on error: Index access is out of bounds
    frame_dig -5
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/salvo/contract.py:275-276
    // # Fail transaction unless the assertion below evaluates True
    // srt.assert_coords_in_range(row, col)
    dup2
    callsub assert_coords_in_range
    // smart_contracts/salvo/contract.py:278
    // srt.convert_grid_coords_to_index(row, col)
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:279
    // == self.box_game_character[Txn.sender].position
    bytec_3 // "c_"
    txn Sender
    concat
    box_get
    assert // check self.box_game_character entry exists
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/salvo/contract.py:278-279
    // srt.convert_grid_coords_to_index(row, col)
    // == self.box_game_character[Txn.sender].position
    b==
    // smart_contracts/salvo/contract.py:277-280
    // assert (
    //     srt.convert_grid_coords_to_index(row, col)
    //     == self.box_game_character[Txn.sender].position
    // ), err.POSITION_MISMATCH
    assert // Position mismatch. Position value must be equal to expected corresponding state value.
    // smart_contracts/salvo/contract.py:283
    // movement.length <= self.box_game_character[Txn.sender].move_points
    bytec_3 // "c_"
    txn Sender
    concat
    box_get
    assert // check self.box_game_character entry exists
    extract 2 1 // on error: Index access is out of bounds
    frame_dig -4
    intc_1 // 0
    extract_uint16
    dup
    frame_bury 10
    itob
    b>=
    // smart_contracts/salvo/contract.py:282-284
    // assert (
    //     movement.length <= self.box_game_character[Txn.sender].move_points
    // ), err.MOVEMENT_OVERFLOW
    assert // Movement overflow. Ensure movement length (num of indicies) is within valid range.
    // smart_contracts/salvo/contract.py:286
    // assert action <= 1, err.ACTION_OVERFLOW
    frame_dig -3
    bytec 4 // 0x01
    b<=
    assert // Action overflow. Ensure action index is within valid range.
    // smart_contracts/salvo/contract.py:287
    // assert direction <= 3, err.DIRECTION_OVERFLOW
    frame_dig -2
    pushbytes 0x03
    b<=
    assert // Direction overflow. Ensure direction index is within valid range.
    // smart_contracts/salvo/contract.py:289-290
    // # Initialize preimage byte array for MiMC hashing
    // preimage = Bytes()
    pushbytes 0x
    frame_bury 3
    intc_1 // 0
    frame_bury 9

mimc_tester_for_header@1:
    // smart_contracts/salvo/contract.py:292
    // for new_coords in movement:
    frame_dig 9
    frame_dig 10
    <
    bz mimc_tester_after_for@10
    frame_dig -4
    extract 2 0
    frame_dig 9
    intc_2 // 2
    *
    intc_2 // 2
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // smart_contracts/salvo/contract.py:293-294
    // # Extract new row and new column values from the given movement argument
    // new_row, new_col = new_coords.native
    dup
    extract 0 1 // on error: Index access is out of bounds
    dup
    cover 2
    frame_bury 2
    extract 1 1 // on error: Index access is out of bounds
    dup
    frame_bury 0
    // smart_contracts/salvo/contract.py:296-297
    // # Fail transaction unless the assertion below evaluates True
    // srt.assert_coords_in_range(new_row, new_col)
    callsub assert_coords_in_range
    // smart_contracts/salvo/contract.py:301
    // UInt64(1),
    intc_0 // 1
    // smart_contracts/salvo/contract.py:302
    // self.box_game_grid,
    bytec_2 // "g_"
    // smart_contracts/salvo/contract.py:299-304
    // # Find valid neighbors from current position coords
    // valid_path_neighbors = srt.find_valid_path_neighbors(
    //     UInt64(1),
    //     self.box_game_grid,
    //     position,
    // )
    frame_dig -5
    callsub find_valid_path_neighbors
    swap
    frame_bury 5
    // smart_contracts/salvo/contract.py:306-307
    // # Check if the move is among the valid neighbors
    // is_move_valid = False
    intc_1 // 0
    frame_bury 7
    // smart_contracts/salvo/contract.py:308
    // for i in urange(valid_path_neighbors[1].native):
    btoi
    frame_bury 12
    intc_1 // 0
    frame_bury 6

mimc_tester_for_header@3:
    // smart_contracts/salvo/contract.py:308
    // for i in urange(valid_path_neighbors[1].native):
    frame_dig 6
    frame_dig 12
    <
    frame_dig 7
    frame_bury 8
    bz mimc_tester_after_for@8
    // smart_contracts/salvo/contract.py:309
    // if new_coords == valid_path_neighbors[0][i]:
    frame_dig 6
    intc_2 // 2
    *
    frame_dig 5
    swap
    intc_2 // 2
    extract3 // on error: Index access is out of bounds
    frame_dig 1
    ==
    bz mimc_tester_after_if_else@6
    // smart_contracts/salvo/contract.py:310
    // is_move_valid = True
    intc_0 // 1
    frame_bury 8

mimc_tester_after_for@8:
    frame_dig 8
    // smart_contracts/salvo/contract.py:313
    // assert is_move_valid, "invalid move in move_sequence"
    assert // invalid move in move_sequence
    // smart_contracts/salvo/subroutines.py:96-97
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    pushint 31 // 31
    bzero
    dup
    frame_dig 2
    concat
    // smart_contracts/salvo/contract.py:315-316
    // # Append the validated move to preimage
    // preimage += srt.u8_to_fr32(new_row)
    frame_dig 3
    swap
    concat
    // smart_contracts/salvo/subroutines.py:96-97
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    swap
    frame_dig 0
    concat
    // smart_contracts/salvo/contract.py:317
    // preimage += srt.u8_to_fr32(new_col)
    concat
    frame_bury 3
    frame_dig 9
    intc_0 // 1
    +
    frame_bury 9
    frame_dig 1
    frame_bury -5
    b mimc_tester_for_header@1

mimc_tester_after_if_else@6:
    // smart_contracts/salvo/contract.py:308
    // for i in urange(valid_path_neighbors[1].native):
    frame_dig 6
    intc_0 // 1
    +
    frame_bury 6
    b mimc_tester_for_header@3

mimc_tester_after_for@10:
    // smart_contracts/salvo/contract.py:329
    // UInt64(1),
    intc_0 // 1
    // smart_contracts/salvo/contract.py:330
    // self.box_game_grid,
    bytec_2 // "g_"
    // smart_contracts/salvo/contract.py:327-332
    // # After processing the full sequence, get valid neighbors of the last position
    // valid_path_neighbors = srt.find_valid_path_neighbors(
    //     UInt64(1),
    //     self.box_game_grid,
    //     position,
    // )
    frame_dig -5
    callsub find_valid_path_neighbors
    swap
    frame_bury 5
    // smart_contracts/salvo/contract.py:337-339
    // # for i in urange(count.native):
    // #     testko.append(neighbors_array[i])
    // testko = arc4.DynamicArray[ta.GridCoords]()
    bytec 10 // 0x0000
    frame_bury 4
    // smart_contracts/salvo/contract.py:340
    // for i in urange(valid_path_neighbors[1].native):
    btoi
    frame_bury 11
    intc_1 // 0
    frame_bury 6

mimc_tester_for_header@11:
    // smart_contracts/salvo/contract.py:340
    // for i in urange(valid_path_neighbors[1].native):
    frame_dig 6
    frame_dig 11
    <
    bz mimc_tester_after_for@14
    // smart_contracts/salvo/contract.py:341
    // coords = valid_path_neighbors[0][i]
    frame_dig 6
    dup
    intc_2 // 2
    *
    frame_dig 5
    swap
    intc_2 // 2
    extract3 // on error: Index access is out of bounds
    // smart_contracts/salvo/contract.py:342
    // testko.append(coords)
    frame_dig 4
    extract 2 0
    swap
    concat
    dup
    len
    intc_2 // 2
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    // smart_contracts/salvo/contract.py:340
    // for i in urange(valid_path_neighbors[1].native):
    intc_0 // 1
    +
    frame_bury 6
    b mimc_tester_for_header@11

mimc_tester_after_for@14:
    // smart_contracts/salvo/contract.py:350-354
    // # return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    // # return output
    // # return (preimage, direction)
    // # return testko
    // return testko
    frame_dig 4
    frame_bury 0
    retsub


// smart_contracts.salvo.contract.Salvo.update() -> void:
update:
    // smart_contracts/salvo/contract.py:365
    // assert TemplateVar[bool]("UPDATABLE"), err.UPDATABLE_NOT_TRUE
    intc 6 // TMPL_UPDATABLE
    assert // Template variable 'UPDATABLE' needs to be 'True' at deploy-time.
    // smart_contracts/salvo/contract.py:366
    // assert Txn.sender == Global.creator_address, err.SENDER_NOT_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Only app creator can act as the sender address.
    retsub
