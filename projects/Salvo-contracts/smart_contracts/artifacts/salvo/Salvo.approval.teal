#pragma version 11
#pragma typetrack false

// smart_contracts.salvo.contract.Salvo.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 32 2 TMPL_GEN_UNIX TMPL_UPDATABLE
    bytecblock 0x151f7c75 0x00 "c_" "g_" "r_" "s_" "l_" "game_id" 0x068101
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn NumAppArgs
    bz main_after_if_else@20
    pushbytess 0x6333cd9d 0xb66d2f56 0x8996bb37 0x5381d6a8 0x7815fe41 0x0b42d12a 0xbbfa8e01 0xf85053ad 0x06f0d132 0x5be219f0 0x3ffbca24 0x81e90542 0xfd1cd76a 0xf7172148 0xa0e81872 // method "calc_single_box_cost(uint8,uint16)uint64", method "read_gen_unix()uint64", method "read_grid_cell_value_by_index(uint64,uint8)uint8", method "read_grid_cell_value_at_coords(uint64,uint8,uint8)uint8", method "does_box_user_registry_exist(account)bool", method "does_box_game_grid_exist(uint64)bool", method "does_box_game_state_exist(uint64)bool", method "does_box_game_character_exist(account)bool", method "read_box_game_lobby(uint64)address[]", method "generate()void", method "get_box_user_registry(pay)void", method "new_game(pay,pay,pay,pay,pay,uint8)void", method "commit_turn(uint64,uint256)void", method "mimc_tester()byte[]", method "update()void"
    txna ApplicationArgs 0
    match main_calc_single_box_cost_route@5 main_read_gen_unix_route@6 main_read_grid_cell_value_by_index_route@7 main_read_grid_cell_value_at_coords_route@8 main_does_box_user_registry_exist_route@9 main_does_box_game_grid_exist_route@10 main_does_box_game_state_exist_route@11 main_does_box_game_character_exist_route@12 main_read_box_game_lobby_route@13 main_generate_route@14 main_get_box_user_registry_route@15 main_new_game_route@16 main_commit_turn_route@17 main_mimc_tester_route@18 main_update_route@19

main_after_if_else@20:
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    intc_1 // 0
    return

main_update_route@19:
    // smart_contracts/salvo/contract.py:417
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main_mimc_tester_route@18:
    // smart_contracts/salvo/contract.py:345
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub mimc_tester
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_commit_turn_route@17:
    // smart_contracts/salvo/contract.py:257
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:257
    // @arc4.abimethod
    callsub commit_turn
    intc_0 // 1
    return

main_new_game_route@16:
    // smart_contracts/salvo/contract.py:161
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    pushint 5 // 5
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 4 // 4
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/salvo/contract.py:161
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_get_box_user_registry_route@15:
    // smart_contracts/salvo/contract.py:137
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/salvo/contract.py:137
    // @arc4.abimethod
    callsub get_box_user_registry
    intc_0 // 1
    return

main_generate_route@14:
    // smart_contracts/salvo/contract.py:125-126
    // # Generate the smart contract application client
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_read_box_game_lobby_route@13:
    // smart_contracts/salvo/contract.py:101-102
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:101-102
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    callsub read_box_game_lobby
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_character_exist_route@12:
    // smart_contracts/salvo/contract.py:96-97
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:96-97
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_character_exist
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_state_exist_route@11:
    // smart_contracts/salvo/contract.py:91-92
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:91-92
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_state_exist
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_grid_exist_route@10:
    // smart_contracts/salvo/contract.py:86-87
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:86-87
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_grid_exist
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_user_registry_exist_route@9:
    // smart_contracts/salvo/contract.py:81-82
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:81-82
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_user_registry_exist
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_at_coords_route@8:
    // smart_contracts/salvo/contract.py:71-72
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/salvo/contract.py:71-72
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_at_coords
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_by_index_route@7:
    // smart_contracts/salvo/contract.py:63-64
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:63-64
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_by_index
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_gen_unix_route@6:
    // smart_contracts/salvo/contract.py:58-59
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:61
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 4 // TMPL_GEN_UNIX
    // smart_contracts/salvo/contract.py:58-59
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calc_single_box_cost_route@5:
    // smart_contracts/salvo/contract.py:44-45
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:44-45
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_cost
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.salvo.subroutines.get_grid_cell_value(game_id: uint64, box_game_grid: bytes, i: bytes) -> bytes:
get_grid_cell_value:
    // smart_contracts/salvo/subroutines.py:199-203
    // # Get the value of a grid cell at the equivalent flattened 1D array index
    // @subroutine
    // def get_grid_cell_value(
    //     game_id: UInt64, box_game_grid: BoxMap[UInt64, ta.GameGrid], i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/subroutines.py:204-205
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in box_game_grid, err.GAME_ID_NOT_FOUND
    frame_dig -3
    itob
    frame_dig -2
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/subroutines.py:206
    // assert i.native < cst.GRID_CELL_TOTAL, err.INVALID_POS_INDEX
    frame_dig -1
    btoi
    dup
    pushint 121 // 121
    <
    assert // Invalid position index. Ensure index value is within valid range.
    // smart_contracts/salvo/subroutines.py:208-209
    // # Access the game grid box contents, at the given index, and return the byte value
    // return box_game_grid[game_id][i.native]
    swap
    box_get
    assert // check BoxMap entry exists
    swap
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    retsub


// smart_contracts.salvo.contract.Salvo.calc_single_box_cost(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_cost:
    // smart_contracts/salvo/contract.py:44-48
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_cost(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/salvo/contract.py:52
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/salvo/contract.py:51
    // size_cost = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/salvo/contract.py:51-53
    // size_cost = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/salvo/contract.py:55-56
    // # Return single box total cost amount
    // return base_cost.native + size_cost
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_by_index(game_id: uint64, i: bytes) -> bytes:
read_grid_cell_value_by_index:
    // smart_contracts/salvo/contract.py:63-67
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_by_index(
    //     self, game_id: UInt64, i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 2 1
    // smart_contracts/salvo/contract.py:68-69
    // # Return byte value at grid cell index
    // return srt.get_grid_cell_value(game_id, self.box_game_grid, i)
    frame_dig -2
    bytec_3 // "g_"
    frame_dig -1
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_at_coords(game_id: uint64, x: bytes, y: bytes) -> bytes:
read_grid_cell_value_at_coords:
    // smart_contracts/salvo/contract.py:71-75
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_at_coords(
    //     self, game_id: UInt64, x: arc4.UInt8, y: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/subroutines.py:192
    // row.native * cst.GRID_SIZE + col.native
    frame_dig -2
    btoi
    pushint 11 // 11
    *
    frame_dig -1
    btoi
    +
    // smart_contracts/salvo/subroutines.py:195-196
    // # Return index value wrapped in an UInt8 data type
    // return arc4.UInt8(i)
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/salvo/contract.py:76-79
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    frame_dig -3
    // smart_contracts/salvo/contract.py:78
    // game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    bytec_3 // "g_"
    // smart_contracts/salvo/contract.py:76-79
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    uncover 2
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_user_registry_exist(account: bytes) -> uint64:
does_box_user_registry_exist:
    // smart_contracts/salvo/contract.py:81-83
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_user_registry_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:84
    // return self.box_user_registry.maybe(account)[1]
    bytec 4 // "r_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_grid_exist(game_id: uint64) -> uint64:
does_box_game_grid_exist:
    // smart_contracts/salvo/contract.py:86-88
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_grid_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:89
    // return self.box_game_grid.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec_3 // "g_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_state_exist(game_id: uint64) -> uint64:
does_box_game_state_exist:
    // smart_contracts/salvo/contract.py:91-93
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_state_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:94
    // return self.box_game_state.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec 5 // "s_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_character_exist(account: bytes) -> uint64:
does_box_game_character_exist:
    // smart_contracts/salvo/contract.py:96-98
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_character_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:99
    // return self.box_game_character.maybe(account)[1]
    bytec_2 // "c_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.read_box_game_lobby(game_id: uint64) -> bytes:
read_box_game_lobby:
    // smart_contracts/salvo/contract.py:101-103
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    // def read_box_game_lobby(self, game_id: UInt64) -> ta.GameLobby:
    proto 1 1
    intc_1 // 0
    dup
    // smart_contracts/salvo/contract.py:104-105
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in self.box_game_lobby, err.GAME_ID_NOT_FOUND
    frame_dig -1
    itob
    bytec 6 // "l_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/contract.py:107-108
    // # Retrieve byte array of current user addresses from the box using the game id parameter
    // game_lobby_b_arr = self.box_game_lobby[game_id]
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_lobby entry exists
    // smart_contracts/salvo/contract.py:110-111
    // # Define a dynamic array to append all remaining active users
    // users_in_lobby = ta.GameLobby()
    pushbytes 0x0000
    swap
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    len
    intc_1 // 0

read_box_game_lobby_for_header@1:
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 4
    <
    bz read_box_game_lobby_after_for@6
    // smart_contracts/salvo/contract.py:115-116
    // # Extract the bytes representing the user address
    // user_addr_bytes = op.extract(game_lobby_b_arr, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    intc_2 // 32
    extract3
    dup
    frame_bury 0
    // smart_contracts/salvo/contract.py:117-118
    // # Only append address if its bytes do NOT equal to a zeroed byte array of size 32
    // if user_addr_bytes != Bytes(cst.ZEROED_ADDR_BYTES):
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    frame_dig 3
    frame_bury 1
    bz read_box_game_lobby_after_if_else@4
    // smart_contracts/salvo/contract.py:120
    // users_in_lobby.append(arc4.Address(user_account))
    frame_dig 3
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    intc_2 // 32
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

read_box_game_lobby_after_if_else@4:
    frame_dig 1
    frame_bury 3
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    intc_2 // 32
    +
    frame_bury 5
    b read_box_game_lobby_for_header@1

read_box_game_lobby_after_for@6:
    // smart_contracts/salvo/contract.py:122-123
    // # Return the array containing the remaining active users in the game lobby
    // return users_in_lobby
    frame_dig 3
    frame_bury 0
    retsub


// smart_contracts.salvo.contract.Salvo.generate() -> void:
generate:
    // smart_contracts/salvo/contract.py:134-135
    // # Set Global State variables to their default starting values
    // self.game_id = UInt64(1)
    bytec 7 // "game_id"
    intc_0 // 1
    app_global_put
    retsub


// smart_contracts.salvo.contract.Salvo.get_box_user_registry(box_r_pay: uint64) -> void:
get_box_user_registry:
    // smart_contracts/salvo/contract.py:137-141
    // @arc4.abimethod
    // def get_box_user_registry(
    //     self,
    //     box_r_pay: gtxn.PaymentTransaction,
    // ) -> None:
    proto 1 0
    // smart_contracts/salvo/contract.py:142-143
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    global GroupSize
    intc_3 // 2
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:144
    // assert Txn.sender not in self.box_user_registry, err.BOX_FOUND
    bytec 4 // "r_"
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Box found. Ensure the box does not exist.
    // smart_contracts/salvo/contract.py:147-148
    // # assert box_r_pay.amount == cst.BOX_R_COST, err.INSUFFICIENT_PAY_AMOUNT
    // assert box_r_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:150
    // box_r_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:149-151
    // assert (
    //     box_r_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:158
    // expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    global Round
    pushint 30 // 30
    +
    itob
    // smart_contracts/salvo/contract.py:153-159
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    pushbytes 0x0000000000000000000000000000000000
    swap
    concat
    // smart_contracts/salvo/contract.py:153-154
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    bytec 4 // "r_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:153-159
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    swap
    box_put
    retsub


// smart_contracts.salvo.contract.Salvo.new_game(box_g_pay: uint64, box_s_pay: uint64, box_c_pay: uint64, box_l_pay: uint64, stake_pay: uint64, lobby_size: bytes) -> void:
new_game:
    // smart_contracts/salvo/contract.py:161-170
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     box_g_pay: gtxn.PaymentTransaction,
    //     box_s_pay: gtxn.PaymentTransaction,
    //     box_c_pay: gtxn.PaymentTransaction,
    //     box_l_pay: gtxn.PaymentTransaction,
    //     stake_pay: gtxn.PaymentTransaction,
    //     lobby_size: arc4.UInt8,
    // ) -> None:
    proto 6 0
    // smart_contracts/salvo/contract.py:171-172
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 6, err.INVALID_GROUP_SIZE
    global GroupSize
    pushint 6 // 6
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:174
    // assert box_g_pay.amount >= cst.BOX_G_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -6
    gtxns Amount
    pushint 54900 // 54900
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:175
    // assert box_s_pay.amount >= cst.BOX_S_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -5
    gtxns Amount
    pushint 27700 // 27700
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:176-177
    // # assert box_c_pay.amount >= cst.BOX_C_COST, err.INSUFFICIENT_PAY_AMOUNT
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    frame_dig -3
    gtxns Amount
    // smart_contracts/salvo/contract.py:179
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    frame_dig -1
    btoi
    dup
    cover 2
    intc_2 // 32
    *
    dup
    cover 2
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/salvo/contract.py:178
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/salvo/contract.py:176-180
    // # assert box_c_pay.amount >= cst.BOX_C_COST, err.INSUFFICIENT_PAY_AMOUNT
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    // ), err.INSUFFICIENT_PAY_AMOUNT
    swap
    callsub calc_single_box_cost
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:188
    // assert box_g_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -6
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:189
    // assert box_s_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -5
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:190
    // assert box_c_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:191
    // assert box_l_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:192
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match sender address.
    // smart_contracts/salvo/contract.py:195
    // box_g_pay.receiver == Global.current_application_address
    frame_dig -6
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:194-196
    // assert (
    //     box_g_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:198
    // box_s_pay.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:197-199
    // assert (
    //     box_s_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:201
    // box_c_pay.receiver == Global.current_application_address
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:200-202
    // assert (
    //     box_c_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:204
    // box_l_pay.receiver == Global.current_application_address
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:203-205
    // assert (
    //     box_l_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:207
    // stake_pay.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:206-208
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:211
    // lobby_size >= cst.MIN_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x02
    b>=
    // smart_contracts/salvo/contract.py:211-213
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:212
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x04
    b<=
    // smart_contracts/salvo/contract.py:211-213
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:213
    // and lobby_size.native % 2 == 0
    frame_dig 0
    intc_3 // 2
    %
    // smart_contracts/salvo/contract.py:211-213
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bnz new_game_bool_false@4
    intc_0 // 1

new_game_bool_merge@5:
    // smart_contracts/salvo/contract.py:210-214
    // assert (
    //     lobby_size >= cst.MIN_LOBBY_SIZE
    //     and lobby_size <= cst.MAX_LOBBY_SIZE
    //     and lobby_size.native % 2 == 0
    // ), err.INVALID_LOBBY_SIZE
    assert // Invalid Lobby size. Value must be an even number and within permitted bounds.
    // smart_contracts/salvo/contract.py:216-217
    // # Create a new box storage unit for the game grid w/ the current global game_id value as key
    // self.box_game_grid[self.game_id] = ta.GameGrid.from_bytes(cst.GRID_ZEROED_BYTES)
    intc_1 // 0
    bytec 7 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    dup
    itob
    bytec_3 // "g_"
    dig 1
    concat
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    box_put
    // smart_contracts/salvo/contract.py:226
    // expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    global LatestTimestamp
    pushint 1200 // 1200
    +
    itob
    // smart_contracts/salvo/contract.py:227
    // prize_pot=arc4.UInt64(stake_pay.amount),
    frame_dig -2
    gtxns Amount
    itob
    // smart_contracts/salvo/contract.py:228
    // admin_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/salvo/contract.py:221
    // staking_closed=arc4.Bool(False),  # noqa: FBT003
    bytec_1 // 0x00
    // smart_contracts/salvo/contract.py:219-229
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    frame_dig -1
    concat
    // smart_contracts/salvo/contract.py:224
    // active_players=arc4.UInt8(1),
    pushbytes 0x01
    // smart_contracts/salvo/contract.py:219-229
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    // smart_contracts/salvo/contract.py:225
    // box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    pushbytes 0x0020
    // smart_contracts/salvo/contract.py:219-229
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/salvo/contract.py:219-220
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    bytec 5 // "s_"
    dig 2
    concat
    // smart_contracts/salvo/contract.py:219-229
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    swap
    box_put
    // smart_contracts/salvo/contract.py:233-236
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    frame_dig 1
    bzero
    // smart_contracts/salvo/contract.py:233-234
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    bytec 6 // "l_"
    uncover 2
    concat
    // smart_contracts/salvo/contract.py:233-236
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    dup
    box_del
    pop
    dup
    uncover 2
    box_put
    // smart_contracts/salvo/contract.py:238-239
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    bytec_2 // "c_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:238-246
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    //     arc4.Bool(False),  # noqa: FBT003
    //     arc4.UInt8(6),
    //     arc4.UInt8(5),
    //     arc4.UInt8(0),
    //     arc4.UInt8(1),
    //     arc4.UInt256(0),
    // )
    pushbytes 0x00060500010000000000000000000000000000000000000000000000000000000000000000
    box_put
    // smart_contracts/salvo/contract.py:252
    // game_lobby_bref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/salvo/contract.py:254-255
    // # Increment game id by 1 for next new game instance
    // self.game_id += 1
    intc_0 // 1
    +
    bytec 7 // "game_id"
    swap
    app_global_put
    retsub

new_game_bool_false@4:
    intc_1 // 0
    b new_game_bool_merge@5


// smart_contracts.salvo.contract.Salvo.commit_turn(game_id: uint64, turn_hash: bytes) -> void:
commit_turn:
    // smart_contracts/salvo/contract.py:257-262
    // @arc4.abimethod
    // def commit_turn(
    //     self,
    //     game_id: UInt64,
    //     turn_hash: arc4.UInt256,
    // ) -> None:
    proto 2 0
    pushbytes ""
    // smart_contracts/salvo/contract.py:263-265
    // # Fail transaction unless the assertion below evaluates True
    // # assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    // assert game_id in self.box_game_state, err.GAME_ID_NOT_FOUND
    frame_dig -2
    itob
    dup
    bytec 5 // "s_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/contract.py:269
    // account=Txn.sender,
    txn Sender
    swap
    // smart_contracts/salvo/contract.py:271
    // player_count=self.box_game_state[game_id].active_players.native,
    box_get
    assert // check self.box_game_state entry exists
    intc_3 // 2
    getbyte
    // smart_contracts/salvo/subroutines.py:251-252
    // # Calculate total byte length to iterate over based on player count and address size
    // game_lobby_length = player_count * cst.ADDRESS_SIZE
    intc_2 // 32
    *
    // smart_contracts/salvo/subroutines.py:254-255
    // # Initialize flag to track if account is found in game
    // acc_in_game = False
    intc_1 // 0
    // smart_contracts/salvo/subroutines.py:257-258
    // # Iterate through the lobby byte array length in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_lobby_length, cst.ADDRESS_SIZE):
    dup

commit_turn_for_header@2:
    // smart_contracts/salvo/subroutines.py:257-258
    // # Iterate through the lobby byte array length in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_lobby_length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 3
    <
    frame_dig 4
    frame_bury 0
    bz commit_turn_after_for@8
    // smart_contracts/salvo/contract.py:270
    // box_game_lobby=self.box_game_lobby,
    bytec 6 // "l_"
    // smart_contracts/salvo/subroutines.py:259-260
    // # Extract the 32-byte player address at start index i
    // player_addr_bytes = op.extract(box_game_lobby[game_id], i, cst.ADDRESS_SIZE)
    frame_dig 1
    concat
    box_get
    assert // check BoxMap entry exists
    frame_dig 5
    intc_2 // 32
    extract3
    // smart_contracts/salvo/subroutines.py:262-263
    // # Check if the extracted player address bytes match up with the account bytes
    // if account.bytes == player_addr_bytes:
    frame_dig 2
    ==
    bz commit_turn_after_if_else@7
    // smart_contracts/salvo/subroutines.py:264
    // acc_in_game = True
    intc_0 // 1
    frame_bury 0

commit_turn_after_for@8:
    frame_dig 0
    // smart_contracts/salvo/contract.py:267-273
    // assert srt.check_acc_in_game(
    //     game_id=game_id,
    //     account=Txn.sender,
    //     box_game_lobby=self.box_game_lobby,
    //     player_count=self.box_game_state[game_id].active_players.native,
    //     clear_player=False,
    // ), err.PLAYER_NOT_FOUND
    assert // Player not found. Ensure player address is inside the game lobby.
    // smart_contracts/salvo/contract.py:276
    // self.box_game_character[Txn.sender].has_committed_turn.native  # noqa: E712
    bytec_2 // "c_"
    txn Sender
    concat
    box_get
    assert // check self.box_game_character entry exists
    intc_1 // 0
    getbit
    bytec_1 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    // smart_contracts/salvo/contract.py:276-277
    // self.box_game_character[Txn.sender].has_committed_turn.native  # noqa: E712
    // == False
    !
    // smart_contracts/salvo/contract.py:275-278
    // assert (
    //     self.box_game_character[Txn.sender].has_committed_turn.native  # noqa: E712
    //     == False
    // )
    assert
    // smart_contracts/salvo/contract.py:280
    // self.box_game_character[Txn.sender].turn_hash = turn_hash
    bytec_2 // "c_"
    txn Sender
    concat
    dup
    box_get
    assert // check self.box_game_character entry exists
    frame_dig -1
    replace2 5
    box_put
    // smart_contracts/salvo/contract.py:281
    // self.box_game_character[Txn.sender].has_committed_turn = arc4.Bool(
    bytec_2 // "c_"
    txn Sender
    concat
    dup
    box_get
    assert // check self.box_game_character entry exists
    // smart_contracts/salvo/contract.py:281-283
    // self.box_game_character[Txn.sender].has_committed_turn = arc4.Bool(
    //     True  # noqa: FBT003
    // )
    intc_1 // 0
    intc_0 // 1
    setbit
    box_put
    retsub

commit_turn_after_if_else@7:
    // smart_contracts/salvo/subroutines.py:257-258
    // # Iterate through the lobby byte array length in 32-byte chunks (one address per chunk)
    // for i in urange(0, game_lobby_length, cst.ADDRESS_SIZE):
    frame_dig 5
    intc_2 // 32
    +
    frame_bury 5
    b commit_turn_for_header@2


// smart_contracts.salvo.contract.Salvo.mimc_tester() -> bytes:
mimc_tester:
    // smart_contracts/salvo/contract.py:345-346
    // @arc4.abimethod
    // def mimc_tester(self) -> Bytes:
    proto 0 1
    intc_1 // 0
    pushbytes ""

mimc_tester_while_top@8:
    pushint 68610 // 68610
    global OpcodeBudget
    >
    bz mimc_tester_after_while@13
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 8 // 0x068101
    itxn_field ApprovalProgram
    bytec 8 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b mimc_tester_while_top@8

mimc_tester_after_while@13:
    // smart_contracts/salvo/contract.py:374-375
    // # Initialize a preimage byte array that will store scalar input ints for MiMC hashing
    // preimage = Bytes()
    pushbytes 0x
    frame_bury 0
    // smart_contracts/salvo/contract.py:387-391
    // # # Add rest of the scalar inputs
    // # preimage += srt.u8_to_fr32(action)
    // # preimage += srt.u8_to_fr32(direction)
    // # preimage += srt.u64_to_fr32(salt)
    // for i in urange(121):  # urange(121) generates UInt64 values from 0 to 120
    intc_1 // 0
    frame_bury 1

mimc_tester_for_header@1:
    // smart_contracts/salvo/contract.py:387-391
    // # # Add rest of the scalar inputs
    // # preimage += srt.u8_to_fr32(action)
    // # preimage += srt.u8_to_fr32(direction)
    // # preimage += srt.u64_to_fr32(salt)
    // for i in urange(121):  # urange(121) generates UInt64 values from 0 to 120
    frame_dig 1
    pushint 121 // 121
    <
    bz mimc_tester_after_for@4
    // smart_contracts/salvo/contract.py:392
    // preimage += srt.u8_to_fr32(arc4.UInt8(1))
    frame_dig 0
    // smart_contracts/salvo/subroutines.py:162-163
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000001
    // smart_contracts/salvo/contract.py:392
    // preimage += srt.u8_to_fr32(arc4.UInt8(1))
    concat
    frame_bury 0
    // smart_contracts/salvo/contract.py:387-391
    // # # Add rest of the scalar inputs
    // # preimage += srt.u8_to_fr32(action)
    // # preimage += srt.u8_to_fr32(direction)
    // # preimage += srt.u64_to_fr32(salt)
    // for i in urange(121):  # urange(121) generates UInt64 values from 0 to 120
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    b mimc_tester_for_header@1

mimc_tester_after_for@4:
    // smart_contracts/salvo/contract.py:409
    // output = op.mimc(op.MiMCConfigurations.BLS12_381Mp111, preimage)
    frame_dig 0
    mimc BLS12_381Mp111
    // smart_contracts/salvo/contract.py:415
    // return output
    frame_bury 0
    retsub


// smart_contracts.salvo.contract.Salvo.update() -> void:
update:
    // smart_contracts/salvo/contract.py:419
    // assert TemplateVar[bool]("UPDATABLE"), err.UPDATABLE_NOT_TRUE
    intc 5 // TMPL_UPDATABLE
    assert // Template variable 'UPDATABLE' needs to be 'True' at deploy-time.
    // smart_contracts/salvo/contract.py:420
    // assert Txn.sender == Global.creator_address, err.SENDER_NOT_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Only app creator can act as the sender address.
    retsub
