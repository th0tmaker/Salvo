#pragma version 11
#pragma typetrack false

// smart_contracts.salvo.contract.Salvo.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 8 2 1000000 TMPL_GEN_UNIX TMPL_UPDATABLE
    bytecblock 0x00 0x151f7c75 "g_" "r_" "c_" "game_id" "s_" "l_" 0x068101 0x0a0a
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0x6333cd9d 0xb66d2f56 0x8996bb37 0x5381d6a8 0x7815fe41 0x0b42d12a 0xbbfa8e01 0xf85053ad 0x06f0d132 0x5be219f0 0x3ffbca24 0x81e90542 0x52497a8e 0xa0e81872 // method "calc_single_box_cost(uint8,uint16)uint64", method "read_gen_unix()uint64", method "read_grid_cell_value_by_index(uint64,uint8)uint8", method "read_grid_cell_value_at_coords(uint64,uint8,uint8)uint8", method "does_box_user_registry_exist(account)bool", method "does_box_game_grid_exist(uint64)bool", method "does_box_game_state_exist(uint64)bool", method "does_box_game_character_exist(account)bool", method "read_box_game_lobby(uint64)address[]", method "generate()void", method "get_box_user_registry(pay)void", method "new_game(pay,pay,pay,pay,pay,uint8)void", method "mimc_tester(uint8,uint8,uint8,(uint8,uint8)[],uint64)(bool,bool,bool,bool)", method "update()void"
    txna ApplicationArgs 0
    match main_calc_single_box_cost_route@5 main_read_gen_unix_route@6 main_read_grid_cell_value_by_index_route@7 main_read_grid_cell_value_at_coords_route@8 main_does_box_user_registry_exist_route@9 main_does_box_game_grid_exist_route@10 main_does_box_game_state_exist_route@11 main_does_box_game_character_exist_route@12 main_read_box_game_lobby_route@13 main_generate_route@14 main_get_box_user_registry_route@15 main_new_game_route@16 main_mimc_tester_route@17 main_update_route@18

main_after_if_else@19:
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    intc_1 // 0
    return

main_update_route@18:
    // smart_contracts/salvo/contract.py:315
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main_mimc_tester_route@17:
    // smart_contracts/salvo/contract.py:260
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // smart_contracts/salvo/contract.py:260
    // @arc4.abimethod
    callsub mimc_tester
    bytec_0 // 0x00
    intc_1 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 5
    setbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 5
    setbit
    uncover 2
    intc_1 // 0
    getbit
    uncover 3
    intc_0 // 1
    uncover 2
    setbit
    uncover 2
    intc_1 // 0
    getbit
    intc_3 // 2
    swap
    setbit
    swap
    intc_1 // 0
    getbit
    pushint 3 // 3
    swap
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_new_game_route@16:
    // smart_contracts/salvo/contract.py:158
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    pushint 5 // 5
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 4 // 4
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    pushint 3 // 3
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/salvo/contract.py:158
    // @arc4.abimethod
    callsub new_game
    intc_0 // 1
    return

main_get_box_user_registry_route@15:
    // smart_contracts/salvo/contract.py:137
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/salvo/contract.py:137
    // @arc4.abimethod
    callsub get_box_user_registry
    intc_0 // 1
    return

main_generate_route@14:
    // smart_contracts/salvo/contract.py:125-126
    // # Generate the smart contract application client
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub generate
    intc_0 // 1
    return

main_read_box_game_lobby_route@13:
    // smart_contracts/salvo/contract.py:101-102
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:101-102
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    callsub read_box_game_lobby
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_character_exist_route@12:
    // smart_contracts/salvo/contract.py:96-97
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:96-97
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_character_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_state_exist_route@11:
    // smart_contracts/salvo/contract.py:91-92
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:91-92
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_state_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_game_grid_exist_route@10:
    // smart_contracts/salvo/contract.py:86-87
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/salvo/contract.py:86-87
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_game_grid_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_does_box_user_registry_exist_route@9:
    // smart_contracts/salvo/contract.py:81-82
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/salvo/contract.py:81-82
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    callsub does_box_user_registry_exist
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_at_coords_route@8:
    // smart_contracts/salvo/contract.py:71-72
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/salvo/contract.py:71-72
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_at_coords
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_grid_cell_value_by_index_route@7:
    // smart_contracts/salvo/contract.py:63-64
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:63-64
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    callsub read_grid_cell_value_by_index
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_gen_unix_route@6:
    // smart_contracts/salvo/contract.py:58-59
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:61
    // return TemplateVar[UInt64]("GEN_UNIX")
    intc 5 // TMPL_GEN_UNIX
    // smart_contracts/salvo/contract.py:58-59
    // # READ-ONLY: Return the app genesis timestamp in Unix format
    // @arc4.abimethod(readonly=True)
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calc_single_box_cost_route@5:
    // smart_contracts/salvo/contract.py:44-45
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/salvo/contract.py:30-31
    // # Smart contract class
    // class Salvo(ARC4Contract, avm_version=11):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/salvo/contract.py:44-45
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    callsub calc_single_box_cost
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.salvo.subroutines.convert_grid_coords_to_index(x: bytes, y: bytes) -> bytes:
convert_grid_coords_to_index:
    // smart_contracts/salvo/subroutines.py:74-76
    // # Convert the game grid x and y coordinates to array index
    // @subroutine
    // def convert_grid_coords_to_index(x: arc4.UInt8, y: arc4.UInt8) -> arc4.UInt8:
    proto 2 1
    // smart_contracts/salvo/subroutines.py:79
    // x.native < cst.GRID_SIZE and y.native < cst.GRID_SIZE
    frame_dig -2
    btoi
    dup
    pushint 11 // 11
    <
    bz convert_grid_coords_to_index_bool_false@3
    frame_dig -1
    btoi
    pushint 11 // 11
    <
    bz convert_grid_coords_to_index_bool_false@3
    intc_0 // 1

convert_grid_coords_to_index_bool_merge@4:
    // smart_contracts/salvo/subroutines.py:77-80
    // # Fail transaction unless the assertion below evaluates True
    // assert (
    //     x.native < cst.GRID_SIZE and y.native < cst.GRID_SIZE
    // ), err.INVALID_GRID_COORDS
    assert // Grid array coords you are trying to access are out of bounds.
    // smart_contracts/salvo/subroutines.py:82-83
    // # Formula for mapping grid 2D coordinates (x, y) into 1D index (i)
    // i = y.native * cst.GRID_SIZE + x.native  # Example: If x=3, y=2 â†’ 2*12 + 3 = 27
    frame_dig -1
    btoi
    pushint 11 // 11
    *
    frame_dig 0
    +
    // smart_contracts/salvo/subroutines.py:85-86
    // # Return index value wrapped in an UInt8 data type
    // return arc4.UInt8(i)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    swap
    retsub

convert_grid_coords_to_index_bool_false@3:
    intc_1 // 0
    b convert_grid_coords_to_index_bool_merge@4


// smart_contracts.salvo.subroutines.get_grid_cell_value(game_id: uint64, box_game_grid: bytes, i: bytes) -> bytes:
get_grid_cell_value:
    // smart_contracts/salvo/subroutines.py:89-93
    // # Get the value of a grid cell at the corresponding flattened 1D array index
    // @subroutine
    // def get_grid_cell_value(
    //     game_id: UInt64, box_game_grid: BoxMap[UInt64, ta.GameGrid], i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/subroutines.py:94-95
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in box_game_grid, err.GAME_ID_NOT_FOUND
    frame_dig -3
    itob
    frame_dig -2
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/subroutines.py:96
    // assert i.native < cst.TOTAL_GRID_CELLS, err.INVALID_GRID_INDEX
    frame_dig -1
    btoi
    dup
    pushint 121 // 121
    <
    assert // Grid array index you are trying to access is out of range.
    // smart_contracts/salvo/subroutines.py:98-99
    // # Access the game grid box contents, at the given index, and return the byte value
    // return box_game_grid[game_id][i.native]
    swap
    box_get
    assert // check BoxMap entry exists
    swap
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    retsub


// smart_contracts.salvo.contract.Salvo.calc_single_box_cost(key_size: bytes, value_size: bytes) -> uint64:
calc_single_box_cost:
    // smart_contracts/salvo/contract.py:44-48
    // # READ-ONLY: Calculate the minimum balance requirement (MBR) cost for storing a single box unit
    // @arc4.abimethod(readonly=True)
    // def calc_single_box_cost(
    //     self, key_size: arc4.UInt8, value_size: arc4.UInt16
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/salvo/contract.py:52
    // key_size.native + value_size.native
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    // smart_contracts/salvo/contract.py:51
    // size_cost = arc4.UInt16(400).native * (
    pushint 400 // 400
    // smart_contracts/salvo/contract.py:51-53
    // size_cost = arc4.UInt16(400).native * (
    //     key_size.native + value_size.native
    // )  # Size fee (400 per byte * (len(key)+len(value)))
    *
    // smart_contracts/salvo/contract.py:55-56
    // # Return single box total cost amount
    // return base_cost.native + size_cost
    pushint 2500 // 2500
    +
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_by_index(game_id: uint64, i: bytes) -> bytes:
read_grid_cell_value_by_index:
    // smart_contracts/salvo/contract.py:63-67
    // # READ-ONLY: Read game grid cell value at array index under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_by_index(
    //     self, game_id: UInt64, i: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 2 1
    // smart_contracts/salvo/contract.py:68-69
    // # Return byte value at grid cell index
    // return srt.get_grid_cell_value(game_id, self.box_game_grid, i)
    frame_dig -2
    bytec_2 // "g_"
    frame_dig -1
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.read_grid_cell_value_at_coords(game_id: uint64, x: bytes, y: bytes) -> bytes:
read_grid_cell_value_at_coords:
    // smart_contracts/salvo/contract.py:71-75
    // # READ-ONLY: Read game grid cell value at x and y coordinates under the given game id key
    // @arc4.abimethod(readonly=True)
    // def read_grid_cell_value_at_coords(
    //     self, game_id: UInt64, x: arc4.UInt8, y: arc4.UInt8
    // ) -> arc4.UInt8:
    proto 3 1
    // smart_contracts/salvo/contract.py:78
    // game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    frame_dig -2
    frame_dig -1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:76-79
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    frame_dig -3
    // smart_contracts/salvo/contract.py:78
    // game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    bytec_2 // "g_"
    // smart_contracts/salvo/contract.py:76-79
    // # Convert x & y coords to grid cell index, then return byte value at that index
    // return srt.get_grid_cell_value(
    //     game_id, self.box_game_grid, srt.convert_grid_coords_to_index(x, y)
    // )
    uncover 2
    callsub get_grid_cell_value
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_user_registry_exist(account: bytes) -> uint64:
does_box_user_registry_exist:
    // smart_contracts/salvo/contract.py:81-83
    // # READ-ONLY: Return True if user registry box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_user_registry_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:84
    // return self.box_user_registry.maybe(account)[1]
    bytec_3 // "r_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_grid_exist(game_id: uint64) -> uint64:
does_box_game_grid_exist:
    // smart_contracts/salvo/contract.py:86-88
    // # READ-ONLY: Return True if game grid box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_grid_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:89
    // return self.box_game_grid.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec_2 // "g_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_state_exist(game_id: uint64) -> uint64:
does_box_game_state_exist:
    // smart_contracts/salvo/contract.py:91-93
    // # READ-ONLY: Return True if game state box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_state_exist(self, game_id: UInt64) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:94
    // return self.box_game_state.maybe(game_id)[1]
    frame_dig -1
    itob
    bytec 6 // "s_"
    swap
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.does_box_game_character_exist(account: bytes) -> uint64:
does_box_game_character_exist:
    // smart_contracts/salvo/contract.py:96-98
    // # READ-ONLY: Return True if game character box value exists, else False
    // @arc4.abimethod(readonly=True)
    // def does_box_game_character_exist(self, account: Account) -> bool:
    proto 1 1
    // smart_contracts/salvo/contract.py:99
    // return self.box_game_character.maybe(account)[1]
    bytec 4 // "c_"
    frame_dig -1
    concat
    box_get
    bury 1
    retsub


// smart_contracts.salvo.contract.Salvo.read_box_game_lobby(game_id: uint64) -> bytes:
read_box_game_lobby:
    // smart_contracts/salvo/contract.py:101-103
    // # READ-ONLY: Return an array of all active users in the game lobby at time of call
    // @arc4.abimethod(readonly=True)
    // def read_box_game_lobby(self, game_id: UInt64) -> ta.GameLobby:
    proto 1 1
    intc_1 // 0
    dup
    // smart_contracts/salvo/contract.py:104-105
    // # Fail transaction unless the assertion below evaluates True
    // assert game_id in self.box_game_lobby, err.GAME_ID_NOT_FOUND
    frame_dig -1
    itob
    bytec 7 // "l_"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Game ID not found. Ensure the game was created and still exists.
    // smart_contracts/salvo/contract.py:107-108
    // # Retrieve byte array of current user addresses from the box using the game id parameter
    // game_lobby_b_arr = self.box_game_lobby[game_id]
    box_get
    swap
    dup
    uncover 2
    assert // check self.box_game_lobby entry exists
    // smart_contracts/salvo/contract.py:110-111
    // # Define a dynamic array to append all remaining active users
    // users_in_lobby = ta.GameLobby()
    pushbytes 0x0000
    swap
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    len
    intc_1 // 0

read_box_game_lobby_for_header@1:
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    frame_dig 4
    <
    bz read_box_game_lobby_after_for@6
    // smart_contracts/salvo/contract.py:115-116
    // # Extract the bytes representing the user address
    // user_addr_bytes = op.extract(game_lobby_b_arr, i, cst.ADDRESS_SIZE)
    frame_dig 2
    frame_dig 5
    pushint 32 // 32
    extract3
    dup
    frame_bury 0
    // smart_contracts/salvo/contract.py:117-118
    // # Only append address if its bytes do NOT equal to a zeroed byte array of size 32
    // if user_addr_bytes != Bytes(cst.ZEROED_ADDR_BYTES):
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
    !=
    frame_dig 3
    frame_bury 1
    bz read_box_game_lobby_after_if_else@4
    // smart_contracts/salvo/contract.py:120
    // users_in_lobby.append(arc4.Address(user_account))
    frame_dig 3
    extract 2 0
    frame_dig 0
    concat
    dup
    len
    pushint 32 // 32
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1

read_box_game_lobby_after_if_else@4:
    frame_dig 1
    frame_bury 3
    // smart_contracts/salvo/contract.py:113-114
    // # Iterate through the users byte array
    // for i in urange(0, game_lobby_b_arr.length, cst.ADDRESS_SIZE):
    frame_dig 5
    pushint 32 // 32
    +
    frame_bury 5
    b read_box_game_lobby_for_header@1

read_box_game_lobby_after_for@6:
    // smart_contracts/salvo/contract.py:122-123
    // # Return the array containing the remaining active users in the game lobby
    // return users_in_lobby
    frame_dig 3
    frame_bury 0
    retsub


// smart_contracts.salvo.contract.Salvo.generate() -> void:
generate:
    // smart_contracts/salvo/contract.py:134-135
    // # Set Global State variables to their default starting values
    // self.game_id = UInt64(1)
    bytec 5 // "game_id"
    intc_0 // 1
    app_global_put
    retsub


// smart_contracts.salvo.contract.Salvo.get_box_user_registry(box_r_pay: uint64) -> void:
get_box_user_registry:
    // smart_contracts/salvo/contract.py:137-138
    // @arc4.abimethod
    // def get_box_user_registry(self, box_r_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/salvo/contract.py:139-140
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 2, err.INVALID_GROUP_SIZE
    global GroupSize
    intc_3 // 2
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:141
    // assert Txn.sender not in self.box_user_registry, err.BOX_FOUND
    bytec_3 // "r_"
    txn Sender
    concat
    box_len
    bury 1
    !
    assert // Box found. Ensure the does not exist already.
    // smart_contracts/salvo/contract.py:144-145
    // # assert box_r_pay.amount == cst.BOX_R_COST, err.INSUFFICIENT_PAY_AMOUNT
    // assert box_r_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:147
    // box_r_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:146-148
    // assert (
    //     box_r_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:155
    // expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    global Round
    pushint 30 // 30
    +
    itob
    // smart_contracts/salvo/contract.py:150-156
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    pushbytes 0x0000000000000000000000000000000000
    swap
    concat
    // smart_contracts/salvo/contract.py:150-151
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    bytec_3 // "r_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:150-156
    // # Create a new box storage unit for the user registry w/ the sender address value as key
    // self.box_user_registry[Txn.sender] = stc.UserRegistry(
    //     hosting_game=arc4.Bool(False),  # noqa: FBT003
    //     game_id=arc4.UInt64(0),
    //     commit_rand_round=arc4.UInt64(0),
    //     expiry_round=arc4.UInt64(Global.round + cst.BOX_R_EXP_ROUND_DELTA),
    // )
    swap
    box_put
    retsub


// smart_contracts.salvo.contract.Salvo.new_game(box_g_pay: uint64, box_s_pay: uint64, box_c_pay: uint64, box_l_pay: uint64, stake_pay: uint64, lobby_size: bytes) -> void:
new_game:
    // smart_contracts/salvo/contract.py:158-167
    // @arc4.abimethod
    // def new_game(
    //     self,
    //     box_g_pay: gtxn.PaymentTransaction,
    //     box_s_pay: gtxn.PaymentTransaction,
    //     box_c_pay: gtxn.PaymentTransaction,
    //     box_l_pay: gtxn.PaymentTransaction,
    //     stake_pay: gtxn.PaymentTransaction,
    //     lobby_size: arc4.UInt8,
    // ) -> None:
    proto 6 0
    // smart_contracts/salvo/contract.py:168-169
    // # Fail transaction unless the assertion below evaluates True
    // assert Global.group_size == 6, err.INVALID_GROUP_SIZE
    global GroupSize
    pushint 6 // 6
    ==
    assert // Invalid group size. Ensure number of transactions in group is within valid bounds.
    // smart_contracts/salvo/contract.py:171
    // assert box_g_pay.amount >= cst.BOX_G_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -6
    gtxns Amount
    pushint 54900 // 54900
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:172
    // assert box_s_pay.amount >= cst.BOX_S_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -5
    gtxns Amount
    pushint 27700 // 27700
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:173
    // assert box_c_pay.amount >= cst.BOX_C_COST, err.INSUFFICIENT_PAY_AMOUNT
    frame_dig -4
    gtxns Amount
    pushint 18100 // 18100
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:174
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    frame_dig -3
    gtxns Amount
    // smart_contracts/salvo/contract.py:176
    // value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    frame_dig -1
    btoi
    dup
    cover 2
    pushint 32 // 32
    *
    dup
    cover 2
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/salvo/contract.py:175
    // key_size=arc4.UInt8(10),
    pushbytes 0x0a
    // smart_contracts/salvo/contract.py:174-177
    // assert box_l_pay.amount >= self.calc_single_box_cost(
    //     key_size=arc4.UInt8(10),
    //     value_size=arc4.UInt16(cst.ADDRESS_SIZE * lobby_size.native),
    // ), err.INSUFFICIENT_PAY_AMOUNT
    swap
    callsub calc_single_box_cost
    >=
    assert // Insufficient payment amount. Value is not enough to cover the minimum requirements.
    // smart_contracts/salvo/contract.py:179
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    frame_dig -2
    gtxns Amount
    dup
    intc 4 // 1000000
    >=
    // smart_contracts/salvo/contract.py:179-181
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:180
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    frame_dig 2
    pushint 500000000 // 500000000
    <=
    // smart_contracts/salvo/contract.py:179-181
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bz new_game_bool_false@4
    // smart_contracts/salvo/contract.py:181
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    frame_dig 2
    intc 4 // 1000000
    %
    // smart_contracts/salvo/contract.py:179-181
    // stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    // and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    // and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    bnz new_game_bool_false@4
    intc_0 // 1

new_game_bool_merge@5:
    // smart_contracts/salvo/contract.py:178-182
    // assert (
    //     stake_pay.amount >= cst.MIN_STAKE_AMOUNT
    //     and stake_pay.amount <= cst.MAX_STAKE_AMOUNT
    //     and stake_pay.amount % cst.MIN_STAKE_AMOUNT == 0
    // ), err.INVALID_STAKE_AMOUNT
    assert // Invalid stake amount. Value must be a multiple of 1 and within permitted bounds.
    // smart_contracts/salvo/contract.py:184
    // assert box_g_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -6
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:185
    // assert box_s_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -5
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:186
    // assert box_c_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:187
    // assert box_l_pay.sender == Txn.sender, err.INVALID_BOX_PAY_SENDER
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Box payment sender address must match transaction sender address.
    // smart_contracts/salvo/contract.py:188
    // assert stake_pay.sender == Txn.sender, err.INVALID_STAKE_PAY_SENDER
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert // Stake payment sender address must match sender address.
    // smart_contracts/salvo/contract.py:191
    // box_g_pay.receiver == Global.current_application_address
    frame_dig -6
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:190-192
    // assert (
    //     box_g_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:194
    // box_s_pay.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:193-195
    // assert (
    //     box_s_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:197
    // box_c_pay.receiver == Global.current_application_address
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:196-198
    // assert (
    //     box_c_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:200
    // box_l_pay.receiver == Global.current_application_address
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:199-201
    // assert (
    //     box_l_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:203
    // stake_pay.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/salvo/contract.py:202-204
    // assert (
    //     stake_pay.receiver == Global.current_application_address
    // ), err.INVALID_BOX_PAY_RECEIVER
    assert // Box payment receiver address must match application address.
    // smart_contracts/salvo/contract.py:207
    // lobby_size >= cst.MIN_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x02
    b>=
    // smart_contracts/salvo/contract.py:207-209
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@9
    // smart_contracts/salvo/contract.py:208
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    frame_dig -1
    pushbytes 0x04
    b<=
    // smart_contracts/salvo/contract.py:207-209
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bz new_game_bool_false@9
    // smart_contracts/salvo/contract.py:209
    // and lobby_size.native % 2 == 0
    frame_dig 0
    intc_3 // 2
    %
    // smart_contracts/salvo/contract.py:207-209
    // lobby_size >= cst.MIN_LOBBY_SIZE
    // and lobby_size <= cst.MAX_LOBBY_SIZE
    // and lobby_size.native % 2 == 0
    bnz new_game_bool_false@9
    intc_0 // 1

new_game_bool_merge@10:
    // smart_contracts/salvo/contract.py:206-210
    // assert (
    //     lobby_size >= cst.MIN_LOBBY_SIZE
    //     and lobby_size <= cst.MAX_LOBBY_SIZE
    //     and lobby_size.native % 2 == 0
    // ), err.INVALID_LOBBY_SIZE
    assert // Invalid Lobby size. Value must be an even number and within permitted bounds.
    // smart_contracts/salvo/contract.py:212-213
    // # Create a new box storage unit for the game grid w/ the current global game_id value as key
    // self.box_game_grid[self.game_id] = ta.GameGrid.from_bytes(cst.ZEROED_GRID_BYTES)
    intc_1 // 0
    bytec 5 // "game_id"
    app_global_get_ex
    assert // check self.game_id exists
    dup
    itob
    bytec_2 // "g_"
    dig 1
    concat
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    box_put
    // smart_contracts/salvo/contract.py:222
    // expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    global LatestTimestamp
    pushint 1200 // 1200
    +
    itob
    // smart_contracts/salvo/contract.py:223
    // prize_pot=arc4.UInt64(stake_pay.amount),
    frame_dig 2
    itob
    // smart_contracts/salvo/contract.py:224
    // admin_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/salvo/contract.py:217
    // staking_closed=arc4.Bool(False),  # noqa: FBT003
    bytec_0 // 0x00
    // smart_contracts/salvo/contract.py:215-225
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    frame_dig -1
    concat
    // smart_contracts/salvo/contract.py:220
    // active_players=arc4.UInt8(1),
    pushbytes 0x01
    // smart_contracts/salvo/contract.py:215-225
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    // smart_contracts/salvo/contract.py:221
    // box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    pushbytes 0x0020
    // smart_contracts/salvo/contract.py:215-225
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/salvo/contract.py:215-216
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    bytec 6 // "s_"
    dig 2
    concat
    // smart_contracts/salvo/contract.py:215-225
    // # Create a new box storage unit for the game state w/ the current global game_id value as key
    // self.box_game_state[self.game_id] = stc.GameState(
    //     staking_closed=arc4.Bool(False),  # noqa: FBT003
    //     # quick_play_enabled=arc4.Bool(False),  # quick_play_enabled,
    //     lobby_size=lobby_size,
    //     active_players=arc4.UInt8(1),
    //     box_l_start_pos=arc4.UInt16(cst.ADDRESS_SIZE),
    //     expiry_ts=arc4.UInt64(Global.latest_timestamp + cst.PHASE_EXPIRY_INTERVAL),
    //     prize_pot=arc4.UInt64(stake_pay.amount),
    //     admin_address=arc4.Address(Txn.sender),
    // )
    swap
    box_put
    // smart_contracts/salvo/contract.py:229-232
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    frame_dig 1
    bzero
    // smart_contracts/salvo/contract.py:229-230
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    bytec 7 // "l_"
    uncover 2
    concat
    // smart_contracts/salvo/contract.py:229-232
    // # Create a new box storage unit for the game lobby w/ the current global game_id value as key
    // self.box_game_lobby[self.game_id] = op.bzero(
    //     cst.ADDRESS_SIZE * lobby_size.native
    // )  # Assign zeroed bytes to store all player addresses in lobby (32 bytes per player)
    dup
    box_del
    pop
    dup
    uncover 2
    box_put
    // smart_contracts/salvo/contract.py:234-235
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    bytec 4 // "c_"
    txn Sender
    concat
    // smart_contracts/salvo/contract.py:234-241
    // # Create a new box storage unit for the game character w/ the sender address value as key
    // self.box_game_character[Txn.sender] = stc.GameCharacter(
    //     arc4.UInt8(1),
    //     arc4.UInt8(6),
    //     arc4.UInt8(22),
    //     arc4.UInt8(10),
    //     arc4.UInt8(0),
    // )
    pushbytes 0x0106160a00
    box_put
    // smart_contracts/salvo/contract.py:247
    // game_lobby_bref.replace(0, Txn.sender.bytes)
    intc_1 // 0
    txn Sender
    box_replace
    // smart_contracts/salvo/contract.py:249-250
    // # Increment game id by 1 for next new game instance
    // self.game_id += 1
    intc_0 // 1
    +
    bytec 5 // "game_id"
    swap
    app_global_put
    retsub

new_game_bool_false@9:
    intc_1 // 0
    b new_game_bool_merge@10

new_game_bool_false@4:
    intc_1 // 0
    b new_game_bool_merge@5


// smart_contracts.salvo.contract.Salvo.mimc_tester(direction: bytes, action: bytes, current_pos: bytes, move_sequence: bytes, salt: bytes) -> uint64, uint64, uint64, uint64:
mimc_tester:
    // smart_contracts/salvo/contract.py:260-269
    // @arc4.abimethod
    // def mimc_tester(
    //     self,
    //     direction: arc4.UInt8,
    //     action: arc4.UInt8,
    //     current_pos: arc4.UInt8,
    //     # move_points: arc4.UInt8,
    //     move_sequence: ta.MoveSequence,
    //     salt: arc4.UInt64,
    // ) -> tuple[bool, bool, bool, bool]:  # Bytes
    proto 5 4
    intc_1 // 0
    dup
    pushbytes ""
    dupn 8

mimc_tester_while_top@26:
    pushint 5610 // 5610
    global OpcodeBudget
    >
    bz mimc_tester_after_while@31
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 8 // 0x068101
    itxn_field ApprovalProgram
    bytec 8 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b mimc_tester_while_top@26

mimc_tester_after_while@31:
    // smart_contracts/salvo/contract.py:274
    // assert direction <= 3, "direction must be [0, 1, 2, 3]"
    frame_dig -5
    pushbytes 0x03
    b<=
    assert // direction must be [0, 1, 2, 3]
    // smart_contracts/salvo/contract.py:275
    // assert action <= 1, "action must be [0, 1]"
    frame_dig -4
    pushbytes 0x01
    b<=
    assert // action must be [0, 1]
    // smart_contracts/salvo/contract.py:277
    // current_pos == self.box_game_character[Txn.sender].current_pos
    bytec 4 // "c_"
    txn Sender
    concat
    box_get
    assert // check self.box_game_character entry exists
    extract 1 1 // on error: Index access is out of bounds
    frame_dig -3
    b==
    // smart_contracts/salvo/contract.py:276-278
    // assert (
    //     current_pos == self.box_game_character[Txn.sender].current_pos
    // ), "cur pos mismatch"
    assert // cur pos mismatch
    // smart_contracts/salvo/contract.py:281
    // current_pos <= cst.TOTAL_GRID_CELLS
    frame_dig -3
    pushbytes 0x79
    b<=
    // smart_contracts/salvo/contract.py:280-282
    // assert (
    //     current_pos <= cst.TOTAL_GRID_CELLS
    // ), "cur pos must not exceed TOTAL_GRID_CELLS=121"
    assert // cur pos must not exceed TOTAL_GRID_CELLS=121
    // smart_contracts/salvo/subroutines.py:49-50
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    pushint 31 // 31
    bzero
    dup
    frame_bury 1
    dup
    frame_dig -5
    concat
    dig 1
    frame_dig -4
    concat
    // smart_contracts/salvo/contract.py:286
    // preimage += srt.u8_to_fr32(action)
    concat
    // smart_contracts/salvo/subroutines.py:49-50
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    swap
    frame_dig -3
    concat
    // smart_contracts/salvo/contract.py:287
    // preimage += srt.u8_to_fr32(current_pos)
    concat
    frame_bury 0
    // smart_contracts/salvo/contract.py:289
    // for coord in move_sequence:
    frame_dig -2
    intc_1 // 0
    extract_uint16
    frame_bury 2
    intc_1 // 0
    frame_bury 4

mimc_tester_for_header@1:
    // smart_contracts/salvo/contract.py:289
    // for coord in move_sequence:
    frame_dig 4
    frame_dig 2
    <
    bz mimc_tester_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 4
    dup
    cover 2
    intc_3 // 2
    *
    intc_3 // 2
    extract3 // on error: Index access is out of bounds
    // smart_contracts/salvo/contract.py:290
    // x, y = coord.native
    dup
    extract 0 1 // on error: Index access is out of bounds
    swap
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/salvo/contract.py:291
    // assert x < cst.GRID_SIZE, "x out of range"
    dig 1
    pushbytes 0x0b
    b<
    assert // x out of range
    // smart_contracts/salvo/contract.py:292
    // assert y < cst.GRID_SIZE, "y out of range"
    dup
    pushbytes 0x0b
    b<
    assert // y out of range
    // smart_contracts/salvo/subroutines.py:49-50
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    frame_dig 1
    dup
    uncover 3
    concat
    // smart_contracts/salvo/contract.py:293
    // preimage += srt.u8_to_fr32(x)
    frame_dig 0
    swap
    concat
    // smart_contracts/salvo/subroutines.py:49-50
    // # Return big-endian byte array (AVM type: Bytes), UInt8 left-padded w/ zeros to match 32-byte scalar format
    // return op.bzero(31) + u.bytes
    swap
    uncover 2
    concat
    // smart_contracts/salvo/contract.py:294
    // preimage += srt.u8_to_fr32(y)
    concat
    frame_bury 0
    intc_0 // 1
    +
    frame_bury 4
    b mimc_tester_for_header@1

mimc_tester_after_for@4:
    // smart_contracts/salvo/subroutines.py:70-71
    // # Wrap coordinates in a GridCoords tuple object and return
    // return ta.GridCoords((arc4.UInt8(x), arc4.UInt8(y)))
    bytec 9 // 0x0a0a
    // smart_contracts/salvo/subroutines.py:17
    // x, y = coords[0].native, coords[1].native
    intc_1 // 0
    getbyte
    dup
    frame_bury 9
    // smart_contracts/salvo/subroutines.py:70-71
    // # Wrap coordinates in a GridCoords tuple object and return
    // return ta.GridCoords((arc4.UInt8(x), arc4.UInt8(y)))
    bytec 9 // 0x0a0a
    // smart_contracts/salvo/subroutines.py:17
    // x, y = coords[0].native, coords[1].native
    intc_0 // 1
    getbyte
    frame_bury 10
    // smart_contracts/salvo/subroutines.py:19-23
    // up_ok = x > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x - 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    bz mimc_tester_bool_false@10
    // smart_contracts/salvo/subroutines.py:22
    // convert_grid_coords_to_index(arc4.UInt8(x - 1), arc4.UInt8(y)),
    frame_dig 9
    intc_0 // 1
    -
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    frame_dig 10
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:304
    // return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    intc_0 // 1
    bytec_2 // "g_"
    // smart_contracts/salvo/subroutines.py:19-23
    // up_ok = x > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x - 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:23
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:19-23
    // up_ok = x > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x - 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    b==
    bz mimc_tester_bool_false@10
    intc_0 // 1
    frame_bury 8

mimc_tester_bool_merge@11:
    // smart_contracts/salvo/subroutines.py:25
    // down_ok = (x + 1) < cst.GRID_SIZE and get_grid_cell_value(
    frame_dig 9
    intc_0 // 1
    +
    dup
    frame_bury 7
    pushint 11 // 11
    <
    // smart_contracts/salvo/subroutines.py:25-29
    // down_ok = (x + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x + 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    bz mimc_tester_bool_false@14
    // smart_contracts/salvo/subroutines.py:28
    // convert_grid_coords_to_index(arc4.UInt8(x + 1), arc4.UInt8(y)),
    frame_dig 7
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    frame_dig 10
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:304
    // return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    intc_0 // 1
    bytec_2 // "g_"
    // smart_contracts/salvo/subroutines.py:25-29
    // down_ok = (x + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x + 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:29
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:25-29
    // down_ok = (x + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x + 1), arc4.UInt8(y)),
    // ) == arc4.UInt8(0)
    b==
    bz mimc_tester_bool_false@14
    intc_0 // 1
    frame_bury 3

mimc_tester_bool_merge@15:
    // smart_contracts/salvo/subroutines.py:31-35
    // left_ok = y > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y - 1)),
    // ) == arc4.UInt8(0)
    frame_dig 10
    bz mimc_tester_bool_false@18
    // smart_contracts/salvo/subroutines.py:34
    // convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y - 1)),
    frame_dig 9
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    frame_dig 10
    intc_0 // 1
    -
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:304
    // return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    intc_0 // 1
    bytec_2 // "g_"
    // smart_contracts/salvo/subroutines.py:31-35
    // left_ok = y > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y - 1)),
    // ) == arc4.UInt8(0)
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:35
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:31-35
    // left_ok = y > 0 and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y - 1)),
    // ) == arc4.UInt8(0)
    b==
    bz mimc_tester_bool_false@18
    intc_0 // 1
    frame_bury 5

mimc_tester_bool_merge@19:
    // smart_contracts/salvo/subroutines.py:37
    // right_ok = (y + 1) < cst.GRID_SIZE and get_grid_cell_value(
    frame_dig 10
    intc_0 // 1
    +
    dup
    frame_bury 6
    pushint 11 // 11
    <
    // smart_contracts/salvo/subroutines.py:37-41
    // right_ok = (y + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y + 1)),
    // ) == arc4.UInt8(0)
    bz mimc_tester_bool_false@22
    // smart_contracts/salvo/subroutines.py:40
    // convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y + 1)),
    frame_dig 9
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    frame_dig 6
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    callsub convert_grid_coords_to_index
    // smart_contracts/salvo/contract.py:304
    // return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    intc_0 // 1
    bytec_2 // "g_"
    // smart_contracts/salvo/subroutines.py:37-41
    // right_ok = (y + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y + 1)),
    // ) == arc4.UInt8(0)
    uncover 2
    callsub get_grid_cell_value
    // smart_contracts/salvo/subroutines.py:41
    // ) == arc4.UInt8(0)
    bytec_0 // 0x00
    // smart_contracts/salvo/subroutines.py:37-41
    // right_ok = (y + 1) < cst.GRID_SIZE and get_grid_cell_value(
    //     game_id,
    //     box_game_grid,
    //     convert_grid_coords_to_index(arc4.UInt8(x), arc4.UInt8(y + 1)),
    // ) == arc4.UInt8(0)
    b==
    bz mimc_tester_bool_false@22
    intc_0 // 1

mimc_tester_bool_merge@23:
    // smart_contracts/salvo/contract.py:304
    // return srt.check_valid_move(UInt64(1), self.box_game_grid, arc4.UInt8(120))
    frame_dig 8
    frame_dig 3
    frame_dig 5
    uncover 3
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

mimc_tester_bool_false@22:
    intc_1 // 0
    b mimc_tester_bool_merge@23

mimc_tester_bool_false@18:
    intc_1 // 0
    frame_bury 5
    b mimc_tester_bool_merge@19

mimc_tester_bool_false@14:
    intc_1 // 0
    frame_bury 3
    b mimc_tester_bool_merge@15

mimc_tester_bool_false@10:
    intc_1 // 0
    frame_bury 8
    b mimc_tester_bool_merge@11


// smart_contracts.salvo.contract.Salvo.update() -> void:
update:
    // smart_contracts/salvo/contract.py:317
    // assert TemplateVar[bool]("UPDATABLE"), err.UPDATABLE_NOT_TRUE
    intc 6 // TMPL_UPDATABLE
    assert // Template variable 'UPDATABLE' needs to be 'True' at deploy-time.
    // smart_contracts/salvo/contract.py:318
    // assert Txn.sender == Global.creator_address, err.SENDER_NOT_CREATOR
    txn Sender
    global CreatorAddress
    ==
    assert // Only app creator can act as the sender address.
    retsub
